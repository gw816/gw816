<html>
<head>
  <title>5.0新特性.html</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/306387 (zh-CN, DDL); Windows/10.0.0 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="517"/>
<h1>5.0新特性.html</h1>

<div>
<span><div><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">前提：</span></strong></div><div style="MARGIN-LEFT: 18pt; TEXT-INDENT: -18pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">1.<span style="font-weight: normal; font-size: 7pt; line-height: normal; font-family: 'Times New Roman';">     </span></span></strong> <strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">JVM</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">没有变</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">,</span></strong> <strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">编译器改变</span></strong></div><div style="MARGIN-LEFT: 18pt; TEXT-INDENT: -18pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">2.<span style="font-weight: normal; font-size: 7pt; line-height: normal; font-family: 'Times New Roman';">     </span></span></strong> <strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">逐渐和</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">C++</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">融合接近（很多开始被遗弃的</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">C++</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">元素又被捡了回来）</span></strong></div><div style="MARGIN-LEFT: 18pt; TEXT-INDENT: -18pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">3.<span style="font-weight: normal; font-size: 7pt; line-height: normal; font-family: 'Times New Roman';">     </span></span></strong> <strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">程序员开发越发的简单了</span></strong></div><div><strong> </strong></div><div><strong><span style="FONT-SIZE: 14pt; COLOR: #3366ff">5</span></strong><strong><span style="FONT-SIZE: 14pt; COLOR: #3366ff">小点：</span></strong></div><div style="MARGIN-LEFT: 18pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">1</span></strong> <strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">自动封装和自动解封（简单类型和封装类型之间），但只是在必要的时候进行，比如向上就近原则中</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">public static void method(Byte b){}:</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">调用这个方法的时候不会像上就近调用</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">int</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">，而是直接调用这个方法。</span></strong></div><div style="MARGIN-LEFT: 18pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">Integer i = 3 // OK</span></strong> <strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">封箱</span></strong></div><div style="MARGIN-LEFT: 18pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">int i = new Integer(3) // OK</span></strong> <strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">解箱</span></strong></div><div style="MARGIN-LEFT: 18pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">i++ ; // OK ,i</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">是</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">Integer</span></strong></div><div style="MARGIN-LEFT: 18pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">在方法中的参数也可以自动的封箱解箱，但是如果存在两个方法：</span></strong></div><div style="MARGIN-LEFT: 18pt"><strong> </strong></div><div style="MARGIN-LEFT: 18pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">方法重载依然存在：</span></strong></div><div style="MARGIN-LEFT: 18pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">public static void method( Integer I ) {</span></strong> <strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">…</span></strong> <strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">}</span></strong></div><div style="MARGIN-LEFT: 18pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">public static void method( int I ) {</span></strong> <strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">…</span></strong> <strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">}</span></strong></div><div style="MARGIN-LEFT: 18pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">这个时候调用</span></strong> <strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">method( 10 ) //</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">会调用第二个方法，因为封箱和解箱都是在迫不得已的情况下才会被调用。</span></strong></div><div style="MARGIN-LEFT: 18pt"><strong> </strong></div><div style="MARGIN-LEFT: 18pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">public static void method( Byte b ) {</span></strong> <strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">…</span></strong> <strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">}</span></strong></div><div style="MARGIN-LEFT: 18pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">public static void method( short s ) {</span></strong> <strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">…</span></strong> <strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">}</span></strong></div><div style="MARGIN-LEFT: 18pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">这个时候调用</span></strong> <strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">byte b = 1 ; method( byte ) //</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">会调用第二个方法，因为封箱和解箱都是在迫不得已的情况下才会被调用。</span></strong></div><div style="MARGIN-LEFT: 18pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff"> </span></strong></div><div><strong><span style="FONT-SIZE: 12pt">  </span></strong> <strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">同样存在问题：拿</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">byte</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">举例：</span></strong> <strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">byte : 256</span></strong> <strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">种（</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">1</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">个字节）</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">然而</span></strong> <strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">Byte : 257</span></strong> <strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">种（多了一个</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">null</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">）</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">  </span></strong></div><div><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">  </span></strong> <strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">所以如果</span></strong> <strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">Integer I = null ; int i = I ; //</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">会有空指针异常</span></strong></div><div><strong> </strong></div><div><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">  </span></strong> <strong><span style="FONT-SIZE: 12pt; COLOR: #993366">封装类有个重要的特性：就是封装</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #993366">0</span></strong></div><div><strong><span style="FONT-SIZE: 12pt; COLOR: #993366">      </span></strong> <strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">自动解箱要注意的：</span></strong></div><div style="TEXT-INDENT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">Byte b = null;</span></strong></div><div style="TEXT-INDENT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">Byte b = 1;</span></strong></div><div style="TEXT-INDENT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">int i = 0;</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">（默认</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">i=0</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">），有二义性，究竟</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">0</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">是否是有效数字</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">0</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">，还是没有赋值而使用默认给得值；</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00"> </span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">所以此时用</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">Integer</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">就可以避免这样的二义性。</span></strong></div><div><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">例如：在</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">hibernate</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">中使用</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">Long</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">而不是</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">long</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">去设定</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">ID</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">的类型，则</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">hibernate</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">会自动检查类型是否是有效数字</span></strong></div><div><strong> </strong></div><div style="MARGIN-LEFT: 39pt; TEXT-INDENT: -18pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">2<span style="font-weight: normal; font-size: 7pt; line-height: normal; font-family: 'Times New Roman';">       </span></span></strong> <strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">import</span></strong></div><div style="MARGIN-LEFT: 21pt; TEXT-INDENT: 18pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">System.out</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">中的</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">out</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">是</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">System</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">类得公开静态属性</span></strong></div><div style="MARGIN-LEFT: 21pt; TEXT-INDENT: 18pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">静态引入：引入一个类里面的静态成员，则访问的时候可以不写类名直接调用静态成员</span></strong></div><div style="MARGIN-LEFT: 21pt; TEXT-INDENT: 18pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">import static java.lang.System.*;</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">表示引入</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">System</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">中的所有静态属性，则在下面使用的时候</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">out.println(...);   </span></strong></div><div style="MARGIN-LEFT: 21pt; TEXT-INDENT: 18pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">insert</span></strong> <strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">可以简化更多</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">因为可以加入包是静态的方法直接使用</span></strong></div><div style="MARGIN-LEFT: 21pt; TEXT-INDENT: 18pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">例：</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">import</span></strong> <strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">static</span></strong> <strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">java.lang.System.*;</span></strong></div><div style="MARGIN-LEFT: 21pt; TEXT-INDENT: 18pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">public class Test {</span></strong></div><div style="MARGIN-LEFT: 21pt; TEXT-INDENT: 18pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">       public static void main(String[] args) {</span></strong></div><div style="MARGIN-LEFT: 21pt; TEXT-INDENT: 18pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">               out.println(&quot;sdsd&quot;);</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">             </span></strong> <strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">}</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">       }</span></strong></div><div style="MARGIN-LEFT: 39pt; TEXT-INDENT: -18pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">3<span style="font-weight: normal; font-size: 7pt; line-height: normal; font-family: 'Times New Roman';">       </span></span></strong> <strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">新的遍历方法而且非常的方便</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">for/in loop</span></strong></div><div style="MARGIN-LEFT: 21pt; TEXT-INDENT: 18pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">使用该</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">loop</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">得对象必须实现</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">Interable</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">接口</span></strong></div><div style="MARGIN-LEFT: 21pt; TEXT-INDENT: 18pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">例：</span></strong></div><div style="MARGIN-LEFT: 21pt; TEXT-INDENT: 18pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">String ss[] = {</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">“</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">test</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">”</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">,</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">”</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">text</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">”</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">};</span></strong></div><div style="MARGIN-LEFT: 21pt; TEXT-INDENT: 18pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">For(String s:ss){</span></strong></div><div style="MARGIN-LEFT: 21pt; TEXT-INDENT: 18pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">        System.out.ptintln(s);</span></strong></div><div style="MARGIN-LEFT: 21pt; TEXT-INDENT: 18pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">}</span></strong></div><div style="MARGIN-LEFT: 21pt; TEXT-INDENT: 18pt"><strong> </strong></div><div style="MARGIN-LEFT: 39pt; TEXT-INDENT: -18pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">4<span style="font-weight: normal; font-size: 7pt; line-height: normal; font-family: 'Times New Roman';">       </span></span></strong> <strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">变常参数</span></strong> <strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">public static void m ( String</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">…</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">s) </span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">通过编译器的帮忙可以简化很多，比如反射中就不用再把</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">String.class</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">先封装在</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">Class[]</span></strong> <strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">中了</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">而可以直接的是用。</span></strong></div><div style="MARGIN-LEFT: 18pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">但是需要注意在一个方法中只能有一个</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">String</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">…</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">s</span></strong> <strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">，其前面可以跟别的类型参数如</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">int i</span></strong> <strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">，</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">String</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">…</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">s</span></strong></div><div style="MARGIN-LEFT: 18pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">还有就是如果有两个以上的参数</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">String</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">…</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">s</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">必须放在最后参数上。</span></strong></div><div style="MARGIN-LEFT: 18pt"><strong><u><span style="FONT-SIZE: 12pt; COLOR: #99cc00">.</span></u></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">先绝对匹配，如果没有匹配的再去调用</span></strong></div><div style="MARGIN-LEFT: 18pt"><strong><u><span style="FONT-SIZE: 12pt; COLOR: #99cc00">.</span></u></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">变参和数组不能同时存在</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">,</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">变参即数组</span></strong></div><div style="MARGIN-LEFT: 18pt"><strong><u><span style="FONT-SIZE: 12pt; COLOR: #99cc00">.</span></u></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">不能同时存在多个</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">...</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">，一个方法可以有且只能有一个变参，且该变参只能是参数表中的最后一个</span></strong></div><div style="MARGIN-LEFT: 18pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">       </span></strong></div><div style="MARGIN-LEFT: 39pt; TEXT-INDENT: -18pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">5<span style="font-weight: normal; font-size: 7pt; line-height: normal; font-family: 'Times New Roman';">       </span></span></strong> <strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">格式化输出</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">:</span></strong></div><div style="MARGIN-LEFT: 21pt; TEXT-INDENT: 18pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff"> System.out.printf(</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">“</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">%d</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">”</span></strong> <strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">, 4 )</span></strong> <strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">；</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">完全符合</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">C</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">的习惯风格，是很有用的东西。格式在</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">API</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">中写的十分的详细。</span></strong></div><div style="MARGIN-LEFT: 21pt; TEXT-INDENT: 18pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">java.util.Formatter</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">类</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">--</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">〉格式化输出。</span></strong></div><div style="MARGIN-LEFT: 18pt; TEXT-INDENT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">java,util,Scanner</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">类</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">--</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">〉格式化输入。融合了</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">BufferedReader+StringTokinizer</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">的功能</span></strong></div><div><strong> </strong></div><div><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">四大块</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">:</span></strong></div><div style="MARGIN-LEFT: 21pt; TEXT-INDENT: -21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">1.<span style="font-weight: normal; font-size: 7pt; line-height: normal; font-family: 'Times New Roman';">       </span></span></strong> <strong><span style="FONT-SIZE: 12pt; COLOR: fuchsia">★</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">枚举</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">(enum)</span></strong> <strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">（一种数据类型）</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">java.lang.Enum</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">对象要用大写来写</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">其实</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">enum</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">可以用</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">class</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">来实现：</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">Class Season {</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">       public static final Season SPRINT = new Season() ; //</span></strong> <strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">这就是制定的对象</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">       private Season() { } //</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">切记把构造方法写成私有</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">}</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">可以很好的控制参数的种类和数量，保证必须按照程序员安排的选择。</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">提高安全性，避免了无谓的异常抛出。</span></strong></div><div><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">      </span></strong> <strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">同样可以排序：通过</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">CompareTo()</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">方法</span></strong></div><div><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">      </span></strong> <strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">直接通过</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">类名</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">.</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">对象</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">选择所要的对象，而这些对象是程序员写好的，只能是他定义的那几个对象。</span></strong></div><div><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">      </span></strong> <strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">类名</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">[] c =</span></strong> <strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">类名</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">.values()</span></strong> <strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">；</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">可以得到所有的对象。</span></strong></div><div><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">      </span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">Enum</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">中有个很诡异的事情，咱们可以理解</span></strong> <strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">enum</span></strong> <strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">ó</span></strong> <strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">final c lass</span></strong> <strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">但是</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">enum</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">中却可以有抽象方法，而这些抽象方法只能通过定义好的几个对象来实现，而且只能通过匿名的内部类的方法来实现。</span></strong></div><div><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">      </span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: fuchsia">★</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">枚举是一个数据类型</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">,</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">是一个</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">final</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">类</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">,</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">不能有子类</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong> </strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">类型不安全的枚举类型：</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">    </span></strong> <strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">公开静态常量</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong> </strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">类型安全的枚举模式：</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">   </span></strong> <strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">将公开静态常量作为</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">public</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">，将构造方法私有，实现枚举类型</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong> </strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">java 5.0</span></strong> <strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">引入的新类：</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">java.lang.Enum</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong> </strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: fuchsia">★</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">实现一个枚举类型，调用该类的</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">values()</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">方法，则返回枚举值得数组</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">final class Season{   //</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">自己实现的枚举类</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">       public static final Season SPRING = new Season(&quot;</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">春</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">&quot;);</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">       public static final Season SUMMER = new Season(&quot;</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">夏</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">&quot;);</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">}</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong> </strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: fuchsia">★</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">用枚举类</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">:</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">enum Season2{</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">       SPRING(),   //</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">把参数写在</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">()</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">里面</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">       SUMMER();   //</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">枚举值和属性之间用</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">;</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">隔开</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong> </strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">       private String name;</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong> </strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">       private Season2(String name){   </span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">//</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">此处不能写</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">public</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">，必须是私有的，不写就可以，默认就是</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">private</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">              this.name = name;</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">       }</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong> </strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">       public String getName(){</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">              return this.name;</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">       }</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">}</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: fuchsia">★</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">.</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">一个枚举值就是一个枚举对象，构造一个枚举值就是调用相应的构造参数</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong> </strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: fuchsia">★★</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">.final</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">里面不能有枚举类型，枚举本来是</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">final</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">但是隐含的可以用匿名内部类去继承，里面却可以有</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">abstract.</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">例</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">: enum Operation{</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">       ADD{</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">              public abstract double caculator(double d1,double d2){</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">                     return d1+d2;</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">              }</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">       },      </span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">//</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">相当于隐含有一个匿名内部类继承了父类</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">Operation</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">，</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">Operation</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">类已经成为父类，</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">ADD</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">其实是匿名内部类的对象</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">       SUB,</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">       MUL,</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">       PROVIDE;</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong> </strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">      </span></strong> <strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">//</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">抽象方法要求每个枚举值去实现该方法</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">       public abstract double caculator(double d1,double d2){</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">             </span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">       }</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">      </span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">       public static void main(String args[]){</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">              for(Operation o:)</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">       }</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">}</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong> </strong></div><div style="MARGIN-LEFT: 21pt; TEXT-INDENT: -21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">2.<span style="font-weight: normal; font-size: 7pt; line-height: normal; font-family: 'Times New Roman';">       </span></span></strong> <strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">泛型：（编译时信息）</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: fuchsia">★</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">很好的解决了集合中对象很难管理其类型的难题。</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">List&lt;Object&gt; l = new ArrayList&lt;String&gt;() ; //</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">这是错误的这里不存在多态</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">List&lt;String&gt; l = new Arraylist&lt;String&gt;() ; // OK</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">泛型的通配符</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">&lt;?&gt;</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">List &lt; ? extends Number &gt;</span></strong> <strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">表示可以是</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">Number</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">类和其子类</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">List &lt; ? super Number &gt;</span></strong> <strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">表示可以使</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">Number</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">类和其父类</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">public static &lt; E &gt; void m( E[] os , List&lt;E&gt; ls )</span></strong> <strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">这里的</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">&lt;E&gt;</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">很像</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">C++</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">中的模版</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong> </strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: fuchsia">★</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: blue">ArrayList</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: blue">比较数组是类型不安全的，指得是里面的类型强转时有可能转换错误</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong> </strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: blue">public class TestGenerics1{</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: blue">       public static void main(String args[]){</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: blue">              List&lt;String&gt; l = new ArrayList&lt;String&gt;();</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: blue">              l.add(&quot;abc&quot;);</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: blue">              //l.add(123);  </span></strong> <strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">//</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">此处会报错，泛型要求不能放入非字符串</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: blue">              l.get(0);   </span></strong> <strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00"> //</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">取得时候也不需要类型转换</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong> </strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: blue">              for(String s:l){   //</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: blue">用</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: blue">for/in loop</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: blue">打印出</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: blue">list</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: blue">里面的东西</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: blue">                     System.out.println(s);</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: blue">              }</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: blue">             </span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: blue">              List&lt;List&gt; l2 = new ArrayList&lt;List&gt;();</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: blue">              L2.add(new ArrayList());</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: blue">              L2.add(new LinkedList());</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: blue">              L2.add(new Vector());</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: blue">              L2.add(new HashSet());   </span></strong> <strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">//</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">以上都是正确的</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong> </strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: blue">              Set&lt;Number&gt; s = new HashSet&lt;Number&gt;();</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: blue">              s.add(1.2);</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong> </strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: blue">              Map&lt;String,Integer&gt; m = new HashMap&lt;String,Integer&gt;();</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: blue">              m.put(</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: blue">“</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: blue">A</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: blue">”</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: blue">,65);     </span></strong> <strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">//</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">不用强制类型转换了，使用了自动解箱</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: blue">             </span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: blue">              //List&lt;Object&gt; ll = new ArrayList&lt;String&gt;();</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: blue">               |</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">不能这样写，因为对象变量的泛型和对象的泛型必须是一致的，不存在多态</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">               |</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">如果这句话对的话，</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">String</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">泛型就没用了</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: blue">       }    |</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: blue">}        |</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: blue">-------------|--------------------------------------------------------</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">        /|/</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">例：</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">import static java.lang.System.*;</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong> </strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">public class TestGenerics2{</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">       public static void main(String args[]){</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">              List&lt;String&gt; l1= new ArrayList&lt;String&gt;();</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">              l1.add(&quot;abc&quot;);</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong> </strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">              List&lt;Number&gt; l2 = new ArrayList&lt;Number&gt;();</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">              l2.add(23);</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong> </strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">              List&lt;Integer&gt; l3 = new ArrayList&lt;Integer&gt;();</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">              l3.add(23);  </span></strong></div><div style="MARGIN-LEFT: 21pt"><strong> </strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">              List&lt;Object&gt; l4 = new ArrayList&lt;Object&gt;();</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">              l4.add(&quot;123&quot;);</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">              l4.add(456);</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong> </strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">              print(l1); </span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">//</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">如果下面</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">print</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">方法的参数是某一个固定类型的话，或者是</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">Object,</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">这块就不能这样写</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">,</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">出错</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">         </span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">              print(l2);</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong> </strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">       }</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">/////////////////////////////////////////////////////////////////////</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">       static void print(List&lt;?&gt; l){  </span></strong> <strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">// &lt;?&gt;</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">是泛型的通配符，表示什么类型都可以，写</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">Object</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">的话就写死了，上面的调用就会报错</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">              for(Object o:l){</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">                     out.println(o);</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">              }</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">       }</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">/////////////////////////////////////////////////////////////////////</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">      </span></strong> <strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">//</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">如果要</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">l1,l4</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">不可以调用，</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">l2,l3</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">可以调用则可以</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">       static void print(List&lt;? extends Number&gt; l){}  </span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">      </span></strong> <strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">//&lt;? extends Number&gt;</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">带限制范围的泛型通配符</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">,</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">表示</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">?</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">是</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">Number</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">得子类</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">/////////////////////////////////////////////////////////////////////</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">       //</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">如果表示都实现了某个接口，依然用</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">extends</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">      </span></strong> <strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">static void print(List&lt;? extends comparable&gt; l){}  </span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">/////////////////////////////////////////////////////////////////////</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">       //</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">如果要</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">l2,l4</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">可以调用，</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">l1,l3</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">不可以调用则可以</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">       static void print(List&lt;? super Number&gt; l){} </span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">      </span></strong> <strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">//&lt;? super Number&gt;</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">表示</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">?</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">是</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">Number</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">得父类</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">      </span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">}</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: fuchsia">★</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">泛型方法，在修饰符和返回值之间写泛型</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">static void copyArrayToList(Object[] os,List&lt;?&gt; ls){</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">       for(Object o:os){</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">              ls.add(o); </span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00"> //</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">报错，因为</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">os</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">放入</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">List</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">，运行的时候</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">List</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">不知道究竟是什么类型</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">       }</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">}</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong> </strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">正确的是：</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">static</span></strong> <strong><span style="FONT-SIZE: 12pt; COLOR: fuchsia">&lt;E&gt;</span></strong> <strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">void copyArrayToList(</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: fuchsia">E</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">[] os,List</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: fuchsia">&lt;E&gt;</span></strong> <strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">ls){ </span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">//</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">两个参数：一个</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">E</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">类型的数组，一个存放</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">E</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">对象的</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">List</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong> </strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">//</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">必须要保证数组的类型和泛型的类型时一样的，每个数组是字符串的，每个元素都是字符串，所以每个字符串当然可以放在泛型是字符串的</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">List</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">中</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">,</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">所以可以使用泛型方法</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong> </strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">static</span></strong> <strong><span style="FONT-SIZE: 12pt; COLOR: fuchsia">&lt;E,S extends T&gt;</span></strong> <strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">void copyArrayToList(</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: fuchsia">E</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">[] os,List</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: fuchsia">&lt;S&gt;</span></strong> <strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">ls){</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">//</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">两个参数：一个</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">E</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">类型的数组，一个存放</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">E</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">或者</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">E</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">子类的对象的</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">List</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">       for(E o:os){</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">              ls.add(o); </span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">       }</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">}</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: fuchsia">★</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">泛型定义：</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">&lt;E,T&gt;</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">表示定义了两个泛型，多个泛型定义用，隔开，那么在后面的方法参数表、集合的类型等处应用这两个泛型</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff"> .E</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">是什么类型就看调这个方法的时候怎么传参数的</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">public static void main(String args[]){</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">              List&lt;String&gt; l1= new ArrayList&lt;String&gt;();</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">              l1.add(&quot;abc&quot;);</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">              Number[] a1 = new Number[10];</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong> </strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">              List&lt;Number&gt; l2 = new ArrayList&lt;Number&gt;();</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">              l2.add(23);</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">              Number[] a1 = new Number[10];</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong> </strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">              List&lt;Integer&gt; l3 = new ArrayList&lt;Integer&gt;();</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">              l3.add(23);  </span></strong></div><div style="MARGIN-LEFT: 21pt"><strong> </strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">              List&lt;Object&gt; l4 = new ArrayList&lt;Object&gt;();</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">              l4.add(&quot;123&quot;);</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">              l4.add(456);</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong> </strong></div><div style="MARGIN-LEFT: 21pt"><strong> </strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">              copyArrayToList(a1,l1);</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">...</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">}</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">///////////////////////////////////////////////////////</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">//</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">定义泛型的时候也可以限制范围</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">,</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">只能向下不能向上，即只能是</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">extends</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">，不能用</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">super</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong> </strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">static &lt;E super Numner&gt; void copyArrayToList(ObjectE[] os,List&lt;E&gt; ls){ </span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">       for(E o:os){</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">              ls.add(o); </span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">       }</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">}</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">/////////////////////////////////////////////////////////////////////</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">      </span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">      </span></strong> <strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">//</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">如果要</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">E</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">是</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">Number</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">而不是</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">Integer</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #99cc00">，则</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">       static &lt;E extends Numner&amp;comparator&gt; void copyArrayToList(ObjectE[] os,List&lt;E&gt; ls){ </span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">       for(E o:os){</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">              ls.add(o); </span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">       }</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">}</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: fuchsia">&lt;E super Numner&amp;comparator&gt;</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: fuchsia">类名</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: fuchsia">&amp;</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: fuchsia">接口，表示</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: fuchsia">E</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: fuchsia">继承</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: fuchsia">Numner</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: fuchsia">实现</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: fuchsia">comparator</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong> </strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">--------------------------------------------------------------------------</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: fuchsia">★</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">自定义一个泛型类：</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">public class TestGenerics1{</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">       public static void main(String args[]){</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">              MyClass&lt;String&gt; m = new MyClass&lt;String&gt;();</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">              MyClass&lt;Integer&gt; m2 = new MyClass&lt;Integer&gt;();</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">              String s = m.get();  </span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">              Integer i = m2.get();</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">              //System.out.println(m instanseof MyClass&lt;String&gt;);</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">              //</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">泛型是编译时概念，到运行的时候什么泛型都没有了，</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">m instanseof MyClass</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">是到运行时才能确定的，所以这句话是不对的</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">       }</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">}</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">class MyClass &lt;E&gt;{</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">       public void print(E parameter){</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">             </span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">       }</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong> </strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">       public E get(){      //</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">返回类型是泛型</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">              return null;</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">       }</span></strong></div><div style="MARGIN-LEFT: 21pt"><strong><span style="FONT-SIZE: 12pt; COLOR: #3366ff">}</span></strong></div><div style="MARGIN-LEFT: 18pt; TEXT-INDENT: -18pt"><span style="FONT-SIZE: 12pt; COLOR: fuchsia">★<span style="font-size: 7pt; line-height: normal; font-family: 'Times New Roman';">   </span></span> <strong><span style="FONT-SIZE: 12pt; COLOR: fuchsia">★注意：</span></strong></div><div style="MARGIN-LEFT: 18pt"><strong><span style="FONT-SIZE: 12pt; COLOR: blue">*</span></strong> <strong><span style="FONT-SIZE: 12pt; COLOR: blue">不能</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: blue">new</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: blue">一个泛型的对象</span></strong></div><div style="MARGIN-LEFT: 18pt"><strong><span style="FONT-SIZE: 12pt; COLOR: blue">*</span></strong> <strong><span style="FONT-SIZE: 12pt; COLOR: blue">静态方法不能使用类的泛型，</span></strong></div><div style="MARGIN-LEFT: 18pt"><strong><span style="FONT-SIZE: 12pt; COLOR: blue">静态变量不能够使用泛型定义</span></strong></div><div style="MARGIN-LEFT: 18pt"><strong><span style="FONT-SIZE: 12pt; COLOR: blue">public class MyGenericClass&lt;T&gt; {</span></strong></div><div style="MARGIN-LEFT: 18pt"><strong> </strong></div><div style="MARGIN-LEFT: 18pt"><strong><span style="FONT-SIZE: 12pt; COLOR: blue"> public static T value;//</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: blue">错误的定义</span></strong></div><div style="MARGIN-LEFT: 18pt"><strong> </strong></div><div style="MARGIN-LEFT: 18pt"><strong><span style="FONT-SIZE: 12pt; COLOR: blue">}</span></strong></div><div style="MARGIN-LEFT: 18pt"><strong> </strong></div><div style="MARGIN-LEFT: 18pt"><strong><span style="FONT-SIZE: 12pt; COLOR: blue">此外，泛型的定义不会被继承，举个例子来说，如果</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: blue">A</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: blue">是</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: blue">B</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: blue">的子类，而</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: blue">C</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: blue">是一个声明了泛型定义的类型的话，</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: blue">C&lt;A&gt;</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: blue">不是</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: blue">C&lt;B&gt;</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: blue">的子类。为了更好的说明，可以看下面的代码，这段代码是</span></strong></div><div style="MARGIN-LEFT: 18pt"><strong><span style="FONT-SIZE: 12pt; COLOR: blue">错误的。</span></strong></div><div style="MARGIN-LEFT: 18pt"><strong> </strong></div><div style="MARGIN-LEFT: 18pt"><strong><span style="FONT-SIZE: 12pt; COLOR: blue">List&lt;String&gt; strList =new ArrayList&lt;String&gt;();</span></strong></div><div style="MARGIN-LEFT: 18pt"><strong> </strong></div><div style="MARGIN-LEFT: 18pt"><strong><span style="FONT-SIZE: 12pt; COLOR: blue">List&lt;Object&gt; objList=strList; //</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: blue">错误的赋值</span></strong></div><div style="MARGIN-LEFT: 18pt"><strong> </strong></div><div style="MARGIN-LEFT: 18pt"><strong> </strong></div><div style="MARGIN-LEFT: 18pt"><strong> </strong></div><div style="MARGIN-LEFT: 18pt"><strong><span style="FONT-SIZE: 12pt; COLOR: blue">不过这样一段代码是正确的：</span></strong></div><div style="MARGIN-LEFT: 18pt"><strong> </strong></div><div style="MARGIN-LEFT: 18pt"><strong><span style="FONT-SIZE: 12pt; COLOR: blue">List&lt;Object&gt; strList =new ArrayList&lt;Object&gt;();</span></strong></div><div style="MARGIN-LEFT: 18pt"><strong> </strong></div><div style="MARGIN-LEFT: 18pt"><strong><span style="FONT-SIZE: 12pt; COLOR: blue">strList.add(&quot;jsdkfjsdl&quot;);</span></strong></div><div style="MARGIN-LEFT: 18pt"><strong> </strong></div><div style="MARGIN-LEFT: 18pt"><strong> </strong></div><div style="MARGIN-LEFT: 18pt"><strong> </strong></div><div style="MARGIN-LEFT: 18pt"><strong> </strong></div><div style="MARGIN-LEFT: 18pt"><strong> </strong></div><div style="MARGIN-LEFT: 18pt"><strong><span style="FONT-SIZE: 12pt; COLOR: blue">那么，在什么时候我们应该使用统配类型，什么时候我们应该使用泛型函数呢？答案是取决于函数参数之间，函数参数和返回值之间的类型依赖性。</span></strong></div><div style="MARGIN-LEFT: 18pt"><strong> </strong></div><div style="MARGIN-LEFT: 18pt"><strong><span style="FONT-SIZE: 12pt; COLOR: blue">如果一个函数的参数类型与函数返回的参数没有必然关联，同时对于该函数其他的参数的类型也没有依赖关系，那么我们就应该使用统配符，否则就应该使用泛型函数。</span></strong></div><div style="MARGIN-LEFT: 18pt"><strong> </strong></div><div style="MARGIN-LEFT: 18pt"><strong><span style="FONT-SIZE: 12pt; COLOR: blue">为了更清楚地说明这一点，我们可以看一下</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: blue">java.util</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: blue">包中</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: blue">Collections</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: blue">类型几个方法的定义：</span></strong></div><div style="MARGIN-LEFT: 18pt"><strong> </strong></div><div style="MARGIN-LEFT: 18pt"><strong><span style="FONT-SIZE: 12pt; COLOR: blue">class Collections {</span></strong></div><div style="MARGIN-LEFT: 18pt"><strong> </strong></div><div style="MARGIN-LEFT: 18pt"><strong><span style="FONT-SIZE: 12pt; COLOR: blue">        static void swap(List&lt;?&gt; list, int i, int j) {...}</span></strong></div><div style="MARGIN-LEFT: 18pt"><strong> </strong></div><div style="MARGIN-LEFT: 18pt"><strong><span style="FONT-SIZE: 12pt; COLOR: blue">        static &lt;T&gt; void copy  (List&lt;? super T&gt; dest, List&lt;? extends T&gt; src)    {...}</span></strong></div><div style="MARGIN-LEFT: 18pt"><strong> </strong></div><div style="MARGIN-LEFT: 18pt"><strong><span style="FONT-SIZE: 12pt; COLOR: blue">}</span></strong></div><div style="MARGIN-LEFT: 18pt"><strong> </strong></div><div style="MARGIN-LEFT: 18pt"><strong><span style="FONT-SIZE: 12pt; COLOR: blue">其中</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: blue">swap</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: blue">函数实际上也可以这样定义：</span></strong></div><div style="MARGIN-LEFT: 18pt"><strong> </strong></div><div style="MARGIN-LEFT: 18pt"><strong><span style="FONT-SIZE: 12pt; COLOR: blue">static &lt;T&gt;void swap(List&lt;T&gt; list, int i, int j) {...}</span></strong></div><div style="MARGIN-LEFT: 18pt"><strong> </strong></div><div style="MARGIN-LEFT: 18pt"><strong><span style="FONT-SIZE: 12pt; COLOR: blue">但是注意到这里泛型类型参数</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: blue">T</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: blue">只在参数中用到了一次，也就是说它和函数其他部分没有依赖性，这可以看作是我们应该使用</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: blue">?</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: blue">的一个标志。</span></strong></div><div style="MARGIN-LEFT: 18pt"><strong> </strong></div><div style="MARGIN-LEFT: 18pt"><strong><span style="FONT-SIZE: 12pt; COLOR: blue">copy</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: blue">方法中，拷贝源</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: blue">src</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: blue">中的元素必须是</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: blue">dest</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: blue">所能够接受的，</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: blue">src</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: blue">中的元素必须是</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: blue">T</span></strong><strong><span style="FONT-SIZE: 12pt; COLOR: blue">的一个子类，但是具体它是哪种子类我们又不必关心，所以方法中使用了泛型作为一个类型参数，</span></strong></div><div style="MARGIN-LEFT: 18pt"><strong><span style="FONT-SIZE: 12pt; COLOR: blue">同时也用了统配类型作为第二类型参数</span></strong></div><br/><div style="color:gray"><small>来源： &lt;<a href="http://blog.csdn.net/chenpy/article/details/1655448">http://blog.csdn.net/chenpy/article/details/1655448</a><small>&gt;</small></small></div><small><small> </small></small></span>
</div></body></html> 