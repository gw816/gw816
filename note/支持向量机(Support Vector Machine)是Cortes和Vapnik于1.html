<html>
<head>
  <title>支持向量机(Support Vector Machine)是Cortes和Vapnik于1995年首.html</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/306387 (zh-CN, DDL); Windows/10.0.0 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1096"/>
<h1>支持向量机(Support Vector Machine)是Cortes和Vapnik于1995年首.html</h1>

<div>
<span><h2><a href="http://www.cnblogs.com/hellope/archive/2012/07/05/2577814.html">BP神经网络理论</a></h2><div><blockquote><p>科普：神经网络是一种运算模型，由 大量的节点（或称“神经元”，或“单元”）和之间相互联接构成。每个节点代表一种特定的输出函数，称为激励函数（activation function）。每两个节点间的连接都代表一个对于通过该连接信号的加权值，称之为权重（weight），这相当于人工神经网络的记忆。网络的输出则 依网络的连接方式，权重值和激励函数的不同而不同。而网络自身通常都是对自然界某种算法或者函数的逼近，也可能是对一种逻辑策略的表达。 人工神经网络通常是通过一个基于数学统计学类型的学习方法（Learning Method）得以优化，所以人工神经网络也是数学统计学方法的一种实际应用，通过统计学的标准数学方法我们能够得到大量的可以用函数来表达的局部结构空 间，另一方面在人工智能学的人工感知领域，我们通过数学统计学的应用可以来做人工感知方面的决定问题(也就是说通过统计学的方法，人工神经网络能够类似人 一样具有简单的决定能力和简单的判断能力)，这种方法比起正式的逻辑学推理演算更具有优势。</p></blockquote><p> </p><p>单个神经元（理解神经网络第一步）：</p><p> </p><p><img src="支持向量机(Support Vector Machine)是Cortes和Vapnik于1_files/Image.png" type="image/png" data-filename="Image.png" style="height: auto;"/></p><ul type="disc"><li>a1~an为输入向量的各个分量</li><li>w1~wn为神经元各个突触的权值</li><li><span lang="zh-CN">b为偏置</span><span lang="zh-CN">（</span><span lang="en-US">bias</span><span lang="zh-CN">）</span><span lang="zh-CN">，或者称之为阈值（</span><span lang="en-US">threshold</span><span lang="zh-CN">）</span></li><li>f为传递函数，通常为非线性函数。一般有traingd(),tansig(),hardlim()。以下默认为hardlim()</li><li>t为神经元输出</li></ul><p> 数学表示</p><p> </p><p><img src="支持向量机(Support Vector Machine)是Cortes和Vapnik于1_files/Image [1].png" type="image/png" data-filename="Image.png" style="height: auto;"/></p><ul><li>向量W为权向量</li><li>向量A为输入向量，做内积需要用到转置</li><li>b为偏置（bias），或者称之为阈值（threshold）</li><li>f为传递函数，也即激励函数</li></ul><p><img src="支持向量机(Support Vector Machine)是Cortes和Vapnik于1_files/Image [2].png" type="image/png" data-filename="Image.png" style="height: auto;"/></p><p>带有 sigma 函数（顶部）和 cutoff 函数（底部）</p><p>可见，一个神经元的功能是求得输入向量与权向量的内积后，经一个非线性传递函数得到一个标量结果。</p><p><span lang="zh-CN">单个神经元的作用：把一个n维向量空间用一个超平面分割成两部分（称之为判断边界），给定一个输入向量，神经元可以判断出这个向量位于超平面的哪一边。(</span><span lang="en-US">SVM</span><span lang="zh-CN">也即是做的这部分工作，所以说，当单个神经元的时候，</span><span lang="en-US">BP</span><span lang="zh-CN">神经网络做的工作与</span><span lang="en-US">SVM</span><span lang="zh-CN">类似。<span lang="zh-CN">该超平面的方程:WXT + b = 0</span>)</span></p><ul><li>向量W为权向量</li><li>向量X为输入向量</li><li>b为偏置（bias），或者称之为阈值（threshold）</li></ul><p> 首先解释一下单个神经元如何进行分类判断：</p><p> 引入一个阈值逻辑单元（Threshold Logic Unit，TLU）的名词，它可以输入一组加权系数的量，对它们进行求和，如果这个和达到或者超过了某个阈值，输出一个量。</p><p> </p><p>让我们用符号标注这些功能，首先，有输入值以及它们的权系数：X 1, X 2, ..., X n和 W 1, W 2, ..., W n。接着是求和计算出的 X i*W i ，产生了激发层 a，换一种方法表示：</p><p>a = (X1 * W1)+(X2 * W2)+...+(Xi * Wi)+...+ (Xn * Wn)</p><p>阈值称为 theta。最后，输出结果 y。当 a &gt;=theta 时 y=1，反之 y=0。请注意输出可以是连续的，因为它也可以由一个 squash 函数 s（或 sigma）判定，该函数的自变量是 a，函数值在 0 和 1 之间，y=s(a)。</p><p>　　假 设一个 TLU 有两个输入值，它们的权系数等于 1，theta 值等于 1.5。当这个 TLU 输入 &lt;0,0&gt;、&lt;0,1&gt;、&lt;1,0&gt; 和 &lt;1,1&gt; 时，它的输出分别为 0、0、0、1。TLU 将这些输入分为两组：0 组和 1 组。就像懂得逻辑连接（布尔运算 AND）的人脑可以类似地将逻辑连接的句子分类那样，TLU 也懂得一点逻辑连接之类的东西。 </p><p> <span lang="zh-CN">神经网络的学习是模仿大脑调节神经网络连接的原理。</span><span lang="en-US">TLU</span><span lang="zh-CN">通过改变它的权值以及阈值来进行学习。回想上面，我们看到</span><span lang="en-US">SUM(</span><span lang="en-US">)&gt;=</span><span lang="en-US">theta</span><span lang="zh-CN">时候，</span><span lang="en-US">TLU</span><span lang="zh-CN">在临界点是输出的是</span><span lang="en-US">1</span><span lang="zh-CN">而不是</span><span lang="en-US">0</span><span lang="zh-CN">，这就相当于当</span><span lang="en-US">SUM(Wi * Xi</span><span lang="en-US">)  +  (-1 * theta) &gt;=</span><span lang="en-US"> 0</span><span lang="zh-CN">的时候。这时候，我们把</span><span lang="en-US">-1</span><span lang="zh-CN">当做是一个常量输入，而他的权系数</span><span lang="en-US">theta θ</span><span lang="zh-CN">在学习过程</span><span lang="en-US">(</span><span lang="zh-CN">或者说是训练过程</span><span lang="en-US">)</span><span lang="zh-CN">中进行调整。</span><span lang="zh-CN">这样，当 SUM(X i* W i)+ (-1 * theta) &gt;= 0 时，y=1，反之 y=0。</span></p><p>在培训过程中，神经网络输入：</p><ol><li><span lang="zh-CN">一系列需要分类的术语示例</span><span lang="en-US">X(input)</span></li><li value="2"><span lang="zh-CN">它们的正确分类或者目标</span><span lang="en-US">Target</span></li></ol><p>这样的输入可以看成一个向量：&lt;X 1, X 2, ..., X n, theta, t&gt;，这里 t 是一个目标或者正确分类。神经网络用这些来调整权系数，其目的使培训中的目标与其分类相匹配。因为神经网络是有指导的培训。或许你现在会问，神经网络是如何通过“调整权系数”来进行学习的？也即神经网络的学习规则。下面介绍一下：权系数的调整有一个学习规则，一个理想化的学习算法如下所示：</p><div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td><div>理想化的学习算法 fully_trained = FALSE</div><div>DO UNTIL (fully_trained):</div><div>    fully_trained = TRUE</div><div>    FOR EACH training_vector = &lt;X1, X2, ..., Xn, theta, target&gt;::</div><div>                               # Weights compared to theta</div><div>        a = (X1 * W1)+(X2 * W2)+...+(Xn * Wn) - theta</div><div>        y = sigma(a)</div><div>        IF y != target:</div><div>            fully_trained = FALSE</div><div>        FOR EACH Wi:</div><div>        MODIFY_WEIGHT(Wi)      # According to the training rule</div><div>    IF (fully_trained):</div><div>        BREAK</div></td></tr></tbody></table></div><p><span lang="zh-CN">有 一条似乎合理的规则是基于这样一种思想，即权系数和阈值的调整应该由分式 (t - y) 确定。这个规则通过引入 alpha (0 &lt; alpha &lt; 1) 完成。我们把 alpha 称为 学习率。W i 中的更改值等于 (alpha * (t - y)* Xi)。当 alpha 趋向于 0 时，神经网络的权系数的调整变得保守一点；当 alpha 趋向于 1 时，权系数的调整变得激进。一个使用这个规则的神经网络称为 感知器，并且这个规则被称为 </span><span lang="zh-CN">感知器学习规则</span><span lang="zh-CN">。概念一下貌似太多，针对单节点的描述可以暂时到此，对于我们的主题</span><span lang="en-US">BP</span><span lang="zh-CN">网络的学习规则接下来将会描述。</span></p><p>神经元网络：</p><p>单层神经元网络：是最基本的神经元网络形式，由有限个神经元构成，所有神经元的输入向量都是同一个向量。由于每一个神经元都会产生一个标量结果，所以单层神经元的输出是一个向量，向量的维数等于神经元的数目。 示意图：</p><p><img src="支持向量机(Support Vector Machine)是Cortes和Vapnik于1_files/Image [3].png" type="image/png" data-filename="Image.png" style="height: auto;"/></p><p><span lang="zh-CN">多层神经元网络(</span><span lang="en-US">BP</span><span lang="zh-CN">网络图)</span><span lang="zh-CN">：</span></p><p><img src="支持向量机(Support Vector Machine)是Cortes和Vapnik于1_files/Image [4].png" type="image/png" data-filename="Image.png" style="height: auto;"/></p><p><span lang="zh-CN">BP (Back Propagation)神经网络，即误差反传误差反向传播算法的学习过程，由信息的正向传播和误差的反向传播两个过程组成。</span><span lang="zh-CN">由上图可知，</span><span lang="en-US">BP</span><span lang="zh-CN">神经网络是一个三层的网络:</span></p><ul><li><span lang="zh-CN">输入层</span><span lang="en-US">(input layer)</span><span lang="zh-CN">：</span><span lang="zh-CN">输入层各神经元负责接收来自外界的输入信息，并传递给中间层各神经</span><span lang="zh-CN">元；</span></li><li><span lang="zh-CN">隐藏层</span><span lang="en-US">(Hidden Layer)</span><span lang="en-US">:</span><span lang="zh-CN">中间层是内部信息处理层，负责信息变换，根据信息变化能力的需求，中间层可以设计为单隐层或者多隐层结构；最后一个隐层传递到输出层各神经元的信息，经进一步处理后，完成一次学习的正向传播处理过程</span><span lang="zh-CN">；</span></li><li><span lang="zh-CN">输出层</span><span lang="en-US">(Output Layer):</span><span lang="zh-CN">顾名思义，</span><span lang="zh-CN">输出层向外界输出信息处理结果</span><span lang="zh-CN">；</span></li></ul><p><span lang="zh-CN">　 　当实际输出与期望输出不符时，进入误差的反向传播阶段。误差通过输出层，按误差梯度下降的方式修正各层权值，向隐层、输入层逐层反传。周而复始的信息正 向传播和误差反向传播过程，是各层权值不断调整的过程，也是神经网络学习训练的过程，此过程一直进行到网络输出的误差减少到可以接受的程度，或者预先设定 的学习次数为止。</span></p><p><span lang="zh-CN">　　<span lang="zh-CN">好 了，以上对于神经网络的结构以及各个组件之间的运行时关系描述到此为止，那么，现在重要的是：具体是如何在误差反向传播的过程中，对各个层权系数进行调 整？规则是什么？总结上面，调整的目的即是每次训练后减少误差。可以使用最小二乘法或者是梯度下降算法。首先需要介绍一下</span><span lang="en-US">Delta</span><span lang="zh-CN">学习规则</span><span lang="zh-CN">。</span></span></p><p>关于 delta 规则</p><p><span lang="zh-CN">感知器培训规则是基于这样一种思路 </span><span lang="zh-CN">——</span><span lang="zh-CN">权系数的调整是由目标和输出的差分方程表达式决定。而</span><span lang="en-US"> delta </span><span lang="en-US">规则是基于</span><span lang="en-US">梯度降落</span><span lang="zh-CN">（也即梯度下降）</span><span lang="en-US">这样一种思路。在权系数的调整中，神经网络将会找到一种将误差减少到最小的权系数的分配方式。</span><span lang="zh-CN">梯度下降参考</span><span lang="en-US">WIKI</span><span lang="zh-CN">。这里不再摘抄。</span></p><p>为了便于说明，将我们的网络限制为没有隐藏节点，但是可能会有不止一个的输出节点。</p><p>设p是一组培训中的一个元素，t(p,n)是相应的输出节点 n 的目标。<span lang="zh-CN">设y(p,n)</span><span lang="zh-CN">为经过神经网络处理后的结果，</span><span lang="zh-CN">由</span><span lang="zh-CN">前面提到过的</span><span lang="zh-CN">squash函数s决定</span><span lang="en-US">(</span><span lang="zh-CN">还记得我们前面提到说这个函数只是为了将连续的输出对应到我们不连续的分类</span><span lang="en-US">target</span><span lang="zh-CN">么？这个函数本身与神经网络没有关系哈</span><span lang="en-US">)</span><span lang="zh-CN">，这里a</span><span lang="en-US">(</span><span lang="zh-CN">p,n</span><span lang="en-US">)</span><span lang="zh-CN">是与p相关的n的激活函数，或者用(p,n) =</span><span lang="zh-CN">s(a(p,n))表示为与p相关的节点n的squash过的激活函数。</span></p><p><span lang="zh-CN">为网络设定权系数（每个W</span><span lang="en-US">i</span><span lang="zh-CN">），也为每个p和n建立t(p,n)与 y(p,n)的差分</span><span lang="zh-CN">，</span><span lang="zh-CN">这就意味着为每个p设定了网络全部的误差</span><span lang="en-US">(</span><span lang="zh-CN">因为通过这个</span><span lang="en-US">P</span><span lang="zh-CN">求出来的结果有误差，那么久要更新所有的权系数</span><span lang="en-US">)</span><span lang="zh-CN">。因此对于每组权系数来说有一个平均误差。但是 delta 规则取决于求平均值方法的精确度以及误差。我们先不讨论细节问题，只是说一些与某些p和n相关的误差：</span><span lang="en-US">1/</span><span lang="en-US">2*</span><span lang="zh-CN"> square( t(p,n) - y(p,n) ) </span><span lang="zh-CN">；现在对于每个权系数</span><span lang="en-US">Wi</span><span lang="zh-CN">，平均误差定义如下：</span></p><div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td><div>sum = 0</div><div>FOR p = 1 TO M:         # M is number of training vectors</div><div>    FOR n = 1 TO N:     # N is number of output nodes</div><div>        sum = sum + (1/2 * (t(p,n)-y(p,n))^2)</div><div>average = 1/M * sum</div></td></tr></tbody></table></div><p>delta 规则就是依据这个误差的定义来定义的。因为误差是依据那些培训向量来说明的，delta 规则是一种获取一个特殊的权系数集以及一个特殊的向量的算法。而改变权系数将会使神经网络的误差最小化。我们不需要讨论支持这个算法的微积分学，只要认为 任何Wi发生的变化都是如下所示就够了：</p><p>alpha * s'(a(p,n)) * (t(p,n) - y(p,n)) * X(p,i,n)</p><p><span lang="zh-CN">X(p,i,n)是输入到节点n的p中的第i个元素，alpha是已知的学习率。最后 s'(a(p,n))是与p相关的第n个节点激活的 squashing 函数的变化（派生）率，这就是 delta 规则。</span></p><p><span lang="zh-CN">最后说说：</span><span lang="zh-CN">梯度下降算法对学习速率</span><span lang="en-US">alpha</span><span lang="zh-CN">的值非常敏感，学习速率的值越大，步长越大收敛的速度就会越快。学习速率越小，步长就小，需要迭代的次数就会多些。当alpha非常小的时候，权系数向量接近某个将误差最小化的向量。用于权系数调节的基于delta规则的算法就是如此。</span></p><p><span lang="zh-CN">继续回到</span><span lang="en-US">BP</span><span lang="zh-CN">神经网络的讨论，</span><span lang="zh-CN">反向传播这一算法把支持delta规则的分析扩展到了带有隐藏节点的神经网络。为了理解这个问题，设想Bob给Alice讲了一个故事，然后Alice又讲给了Ted</span><span lang="zh-CN">，</span><span lang="zh-CN">Ted 检查了这个事实真相，发现这个故事是错误的。现在 Ted 需要找出哪些错误是Bob造成的而哪些又归咎于Alice。当输出节点从隐藏节点获得输入，网络发现出现了误差，权系数的调整需要一个算法来找出整个误差 是由多少不同的节点造成的，网络需要问，“是谁让我误入歧途？到怎样的程度？如何弥补？”这时，网络该怎么做呢？</span></p><p>同样源于梯度降落原理，在权系数调整分析中的唯一不同是涉及到t(p,n)与y(p,n)的差分。通常来说Wi的改变在于：</p><p>alpha * s'(a(p,n)) * d(n) * X(p,i,n)</p><p>其中d(n)是隐藏节点n的函数，让我们来看：</p><ol><li>n 对任何给出的输出节点有多大影响；</li><li>输出节点本身对网络整体的误差有多少影响。</li></ol><p><img src="支持向量机(Support Vector Machine)是Cortes和Vapnik于1_files/Image [5].png" type="image/png" data-filename="Image.png" style="height: auto;"/></p><p>一 方面，n 影响一个输出节点越多，n 造成网络整体的误差也越多。另一方面，如果输出节点影响网络整体的误差越少，n 对输出节点的影响也相应减少。这里d(j)是对网络的整体误差的基值，W(n,j) 是 n 对 j 造成的影响，d(j) * W(n,j) 是这两种影响的总和。但是 n 几乎总是影响多个输出节点，也许会影响每一个输出结点，这样，d(n) 可以表示为：</p><p>SUM(d(j)*W(n,j))</p><p>这里j是一个从n获得输入的输出节点，联系起来，我们就得到了一个培训规则。</p><p>第1部分：在隐藏节点n和输出节点j之间权系数改变，如下所示：</p><p>alpha * s'(a(p,n))*(t(p,n) - y(p,n)) * X(p,n,j)</p><p>第 2 部分：在输入节点i和输出节点n之间权系数改变，如下所示：</p><p>alpha * s'(a(p,n)) * sum(d(j) * W(n,j)) * X(p,i,n)</p><p>这里每个从n接收输入的输出节点j都不同。关于反向传播算法的基本情况大致如此。</p><p>使误差小到适当的程度要遵循的步骤</p><blockquote><p>第 1 步：输入培训向量。</p><p>第 2 步：隐藏节点计算它们的输出</p><p>第 3 步：输出节点在第 2 步的基础上计算它们的输出。</p><p>第 4 步：计算第 3 步所得的结果和期望值之间的差。</p><p>第 5 步：把第 4 步的结果填入培训规则的第 1 部分。</p><p>第 6 步：对于每个隐藏节点 n，计算 d(n)。</p><p>第 7 步：把第 6 步的结果填入培训规则的第 2 部分。</p></blockquote><p>通常把第 1 步到第 3 步称为 正向传播，把第 4 步到第 7 步称为 反向传播。反向传播的名字由此而来。</p><br/><div>来源： &lt;<a href="http://www.cnblogs.com/hellope/archive/2012/07/05/2577814.html">http://www.cnblogs.com/hellope/archive/2012/07/05/2577814.html</a>&gt;</div>
 </div></span>
</div></body></html> 