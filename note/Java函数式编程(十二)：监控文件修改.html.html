<html>
<head>
  <title>Java函数式编程(十二)：监控文件修改.html</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/306387 (zh-CN, DDL); Windows/10.0.0 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="538"/>
<h1>Java函数式编程(十二)：监控文件修改.html</h1>

<div>
<span><p style="margin: 0px; padding: 5px 0px; font-size: 14px; font-family: Tahoma, Helvetica, Arial, 宋体, sans-serif; line-height: 25.2000007629395px; widows: 1;"><strong>使用flatMap列出子目录</strong></p><p style="margin: 0px; padding: 5px 0px; font-size: 14px; font-family: Tahoma, Helvetica, Arial, 宋体, sans-serif; line-height: 25.2000007629395px; widows: 1;">前面已经看到如何列出指定目录下的文件了。我们再来看下如何遍历指定目录的直接子目录（深度为1），先实现一个简单的版本，然后再用更方便的flatMap()方法来实现。</p><p style="margin: 0px; padding: 5px 0px; font-size: 14px; font-family: Tahoma, Helvetica, Arial, 宋体, sans-serif; line-height: 25.2000007629395px; widows: 1;">我们先用传统的for循环来遍历一个指定的目录。如果子目录中有文件，就添加到列表里；否则就把子目录添加到列表里。最后，打印出所有文件的总数。代码在下面——这个是困难模式的。</p><p style="margin: 0px; padding: 5px 0px; font-size: 14px; font-family: Tahoma, Helvetica, Arial, 宋体, sans-serif; line-height: 25.2000007629395px; widows: 1;"></p><div style="border-left-color: rgb(0, 153, 204); border-left-width: 1px; border-left-style: solid; padding: 0px 3px; margin: 3px auto 0px; width: 640px; clear: both; font-size: 14px; border-top-color: rgb(0, 153, 204); border-top-width: 1px; border-top-style: solid; border-right-color: rgb(0, 153, 204); border-right-width: 1px; border-right-style: solid; line-height: 25.2000007629395px; font-family: Tahoma, Helvetica, Arial, 宋体, sans-serif; widows: 1; background-color: rgb(242, 246, 251); background-position: initial initial; background-repeat: initial initial;"><span style="float: right; line-height: 25.2000007629395px; font-size: 14px;"><a style="color: rgb(51, 51, 51); cursor: pointer;"><u>复制代码</u></a></span>代码如下:</div><div style="border: 1px solid rgb(0, 153, 204); padding: 0px 3px 0px 5px; margin: 0px auto 3px; width: 638px; clear: both; font-size: 14px; line-height: 25.2000007629395px; font-family: Tahoma, Helvetica, Arial, 宋体, sans-serif; widows: 1; background-color: rgb(221, 237, 251); background-position: initial initial; background-repeat: initial initial;"><br/>
public static void listTheHardWay() {<br/>
     List&lt;File&gt; files = new ArrayList&lt;&gt;();<br/>
     File[] filesInCurrentDir = new File(&quot;.&quot;).listFiles();<br/>
     for(File file : filesInCurrentDir) {<br/>
          File[] filesInSubDir = file.listFiles();<br/>
               if(filesInSubDir != null) {<br/>
                     files.addAll(Arrays.asList(filesInSubDir));<br/>
               } else {<br/>
                    files.add(file);<br/>
               }<br/>
      }<br/>
     System.out.println(&quot;Count: &quot; + files.size())<br/>
}<br/></div><p style="margin: 0px; padding: 5px 0px; font-size: 14px; font-family: Tahoma, Helvetica, Arial, 宋体, sans-serif; line-height: 25.2000007629395px; widows: 1;"></p><p style="margin: 0px; padding: 5px 0px; font-size: 14px; font-family: Tahoma, Helvetica, Arial, 宋体, sans-serif; line-height: 25.2000007629395px; widows: 1;">我们先获取当前目录下的文件列表，然后进行遍历。对于每个文件，如果它有子文件，就把它们添加到列表中。这样做是没问题的，不过它有一些常见的问题：可变性，基本类型偏执，命令式，代码冗长，等等。一个叫flatMap()的小方法就可以解决掉这些问题。</p><p style="margin: 0px; padding: 5px 0px; font-size: 14px; font-family: Tahoma, Helvetica, Arial, 宋体, sans-serif; line-height: 25.2000007629395px; widows: 1;">正如这个名字所说的，这个方法在映射后会进行扁平化。它会像map()一样对集合中的元素进行映射。但是和map()方法不同的是，map()方法里面的lambda表达式只是返回一个元素，而这里返回的是一个Stream对象。于是这个方法将多个流压平，将里面的每个元素映射到一个扁平化的流中。</p><p style="margin: 0px; padding: 5px 0px; font-size: 14px; font-family: Tahoma, Helvetica, Arial, 宋体, sans-serif; line-height: 25.2000007629395px; widows: 1;">我们可以用flatMap()来执行各种操作，不过现在手头的这个问题就正好诠释了它的价值。每个子目录都有一个文件的列表或者说流，而我们希望获取当前目录下的所有子目录中的文件列表。</p><p style="margin: 0px; padding: 5px 0px; font-size: 14px; font-family: Tahoma, Helvetica, Arial, 宋体, sans-serif; line-height: 25.2000007629395px; widows: 1;">有一些目录可能是空的，或者说没有子元素。这种情况下，我们将这个空目录或者文件包装成一个流对象。如果我们想忽略某个文件，JDK中的flatMap()方法也可以很好的处理空文件；它会把一个空引用作为一个空集合合并到流里。来看下flatMap()方法的使用。</p><p style="margin: 0px; padding: 5px 0px; font-size: 14px; font-family: Tahoma, Helvetica, Arial, 宋体, sans-serif; line-height: 25.2000007629395px; widows: 1;"></p><div style="border-left-color: rgb(0, 153, 204); border-left-width: 1px; border-left-style: solid; padding: 0px 3px; margin: 3px auto 0px; width: 640px; clear: both; font-size: 14px; border-top-color: rgb(0, 153, 204); border-top-width: 1px; border-top-style: solid; border-right-color: rgb(0, 153, 204); border-right-width: 1px; border-right-style: solid; line-height: 25.2000007629395px; font-family: Tahoma, Helvetica, Arial, 宋体, sans-serif; widows: 1; background-color: rgb(242, 246, 251); background-position: initial initial; background-repeat: initial initial;"><span style="float: right; line-height: 25.2000007629395px; font-size: 14px;"><a style="color: rgb(51, 51, 51); cursor: pointer;"><u>复制代码</u></a></span>代码如下:</div><div style="border: 1px solid rgb(0, 153, 204); padding: 0px 3px 0px 5px; margin: 0px auto 3px; width: 638px; clear: both; font-size: 14px; line-height: 25.2000007629395px; font-family: Tahoma, Helvetica, Arial, 宋体, sans-serif; widows: 1; background-color: rgb(221, 237, 251); background-position: initial initial; background-repeat: initial initial;"><br/>
public static void betterWay() {<br/>
     List&lt;File&gt; files =<br/>
          Stream.of(new File(&quot;.&quot;).listFiles())<br/>
               .flatMap(file -&gt; file.listFiles() == null ?<br/>
                    Stream.of(file) : Stream.of(file.listFiles()))<br/>
               .collect(toList());<br/>
     System.out.println(&quot;Count: &quot; + files.size());<br/>
}<br/></div><p style="margin: 0px; padding: 5px 0px; font-size: 14px; font-family: Tahoma, Helvetica, Arial, 宋体, sans-serif; line-height: 25.2000007629395px; widows: 1;"></p><p style="margin: 0px; padding: 5px 0px; font-size: 14px; font-family: Tahoma, Helvetica, Arial, 宋体, sans-serif; line-height: 25.2000007629395px; widows: 1;">我们先是获取了当前目录的子文件流，然后调用了它的flatMap()方法。然后将一个lambda表达式传给这个方法，这个表达式会返回指定文件的子文件的流。flatMap()方法返回的的是当前目录所有子目录下的文件的集合。我们使用collect()方法以及Collectors里面的toList()(方法把它们收集到一个列表中。</p><p style="margin: 0px; padding: 5px 0px; font-size: 14px; font-family: Tahoma, Helvetica, Arial, 宋体, sans-serif; line-height: 25.2000007629395px; widows: 1;">我们传给flatMap()的这个lambda表达式，它返回的是一个文件的子文件。 如果没有的话，则返回这个文件的流。flatMap()方法优雅地将这个流映射到一个流的集合中，然后将这个集合扁平化，最终合并到一个流中。</p><p style="margin: 0px; padding: 5px 0px; font-size: 14px; font-family: Tahoma, Helvetica, Arial, 宋体, sans-serif; line-height: 25.2000007629395px; widows: 1;">flatMap()方法减少了许多开发的工作——它将两个连续的操作很好的结合到了一起，这通常称为元组 ——用一个优雅的操作就完成了。</p><p style="margin: 0px; padding: 5px 0px; font-size: 14px; font-family: Tahoma, Helvetica, Arial, 宋体, sans-serif; line-height: 25.2000007629395px; widows: 1;">我们已经知道如何使用flatMap()方法来将直接子目录中的所有文件列出来。下面我们来监控一下文件的修改操作。</p><p style="margin: 0px; padding: 5px 0px; font-size: 14px; font-family: Tahoma, Helvetica, Arial, 宋体, sans-serif; line-height: 25.2000007629395px; widows: 1;"><strong>监控文件修改</strong></p><p style="margin: 0px; padding: 5px 0px; font-size: 14px; font-family: Tahoma, Helvetica, Arial, 宋体, sans-serif; line-height: 25.2000007629395px; widows: 1;">我们已经知道如何查找文件及目录，不过如果我们希望在文件创建，修改或删除的时候，能够接收到提示消息的话，这个也非常简单。这样的机制对于监视一些特殊文件比如配置文件，系统资源的改动非常有用。下面我们来探索下Java 7中引入的这个工具，WatchService，它可以用来监控文件的修改。下面我们看到的许多特性都来自JDK 7，而这里最大的改进就是内部迭代器带来的便利性。</p><p style="margin: 0px; padding: 5px 0px; font-size: 14px; font-family: Tahoma, Helvetica, Arial, 宋体, sans-serif; line-height: 25.2000007629395px; widows: 1;">我们先来写个监控当前目录中的文件修改的例子。JDK中的Path类会对应文件系统中的一个实例，它是一个观察者服务的工厂。我们可以给这个服务注册通知事件，就像这样：</p><p style="margin: 0px; padding: 5px 0px; font-size: 14px; font-family: Tahoma, Helvetica, Arial, 宋体, sans-serif; line-height: 25.2000007629395px; widows: 1;"></p><div style="border-left-color: rgb(0, 153, 204); border-left-width: 1px; border-left-style: solid; padding: 0px 3px; margin: 3px auto 0px; width: 640px; clear: both; font-size: 14px; border-top-color: rgb(0, 153, 204); border-top-width: 1px; border-top-style: solid; border-right-color: rgb(0, 153, 204); border-right-width: 1px; border-right-style: solid; line-height: 25.2000007629395px; font-family: Tahoma, Helvetica, Arial, 宋体, sans-serif; widows: 1; background-color: rgb(242, 246, 251); background-position: initial initial; background-repeat: initial initial;"><span style="float: right; line-height: 25.2000007629395px; font-size: 14px;"><a style="color: rgb(51, 51, 51); cursor: pointer;"><u>复制代码</u></a></span>代码如下:</div><div style="border: 1px solid rgb(0, 153, 204); padding: 0px 3px 0px 5px; margin: 0px auto 3px; width: 638px; clear: both; font-size: 14px; line-height: 25.2000007629395px; font-family: Tahoma, Helvetica, Arial, 宋体, sans-serif; widows: 1; background-color: rgb(221, 237, 251); background-position: initial initial; background-repeat: initial initial;"><br/>
inal Path path = Paths.get(&quot;.&quot;);
<p style="margin: 0px; padding: 5px 0px; font-size: 14px;"></p><p style="margin: 0px; padding: 5px 0px; font-size: 14px;">final WatchService watchService =<br/>
       path.getFileSystem()<br/>
           .newWatchService();<br/>
       path.register(watchService, StandardWatchEventKinds.ENTRY_MODIFY);</p><p style="margin: 0px; padding: 5px 0px; font-size: 14px;">System.out.println(&quot;Report any file changed within next 1 minute...&quot;);<br/></p></div><p style="margin: 0px; padding: 5px 0px; font-size: 14px; font-family: Tahoma, Helvetica, Arial, 宋体, sans-serif; line-height: 25.2000007629395px; widows: 1;"></p><p style="margin: 0px; padding: 5px 0px; font-size: 14px; font-family: Tahoma, Helvetica, Arial, 宋体, sans-serif; line-height: 25.2000007629395px; widows: 1;">我们注册了一个WatchService来观察当前目录的修改。你可以轮询这个WatchService来获取目录下文件的修改操作，它会通过一个WatchKey将这些改动返回给我们。一旦我们拿到了这个key，可以遍历它的所有事件来获取文件更新的详细信息。因为可能会有多个文件被同时修改，poll操作可能会返回多个事件。来看下轮询以及遍历的代码。</p><p style="margin: 0px; padding: 5px 0px; font-size: 14px; font-family: Tahoma, Helvetica, Arial, 宋体, sans-serif; line-height: 25.2000007629395px; widows: 1;"></p><div style="border-left-color: rgb(0, 153, 204); border-left-width: 1px; border-left-style: solid; padding: 0px 3px; margin: 3px auto 0px; width: 640px; clear: both; font-size: 14px; border-top-color: rgb(0, 153, 204); border-top-width: 1px; border-top-style: solid; border-right-color: rgb(0, 153, 204); border-right-width: 1px; border-right-style: solid; line-height: 25.2000007629395px; font-family: Tahoma, Helvetica, Arial, 宋体, sans-serif; widows: 1; background-color: rgb(242, 246, 251); background-position: initial initial; background-repeat: initial initial;"><span style="float: right; line-height: 25.2000007629395px; font-size: 14px;"><a style="color: rgb(51, 51, 51); cursor: pointer;"><u>复制代码</u></a></span>代码如下:</div><div style="border: 1px solid rgb(0, 153, 204); padding: 0px 3px 0px 5px; margin: 0px auto 3px; width: 638px; clear: both; font-size: 14px; line-height: 25.2000007629395px; font-family: Tahoma, Helvetica, Arial, 宋体, sans-serif; widows: 1; background-color: rgb(221, 237, 251); background-position: initial initial; background-repeat: initial initial;"><br/>
final WatchKey watchKey = watchService.poll(1, TimeUnit.MINUTES);
<p style="margin: 0px; padding: 5px 0px; font-size: 14px;"></p><p style="margin: 0px; padding: 5px 0px; font-size: 14px;">if(watchKey != null) {<br/>
     watchKey.pollEvents()<br/>
          .stream()<br/>
          .forEach(event -&gt;<br/>
               System.out.println(event.context()));<br/>
}<br/></p></div><p style="margin: 0px; padding: 5px 0px; font-size: 14px; font-family: Tahoma, Helvetica, Arial, 宋体, sans-serif; line-height: 25.2000007629395px; widows: 1;"></p><p style="margin: 0px; padding: 5px 0px; font-size: 14px; font-family: Tahoma, Helvetica, Arial, 宋体, sans-serif; line-height: 25.2000007629395px; widows: 1;">这里可以看到，Java 7和Java 8的特性同时出场了。我们把pollEvents()返回的集合转化成了一个Java 8的Stream，然后使用它的内部迭代器来打印出每个文件的详细的更新信息。</p><p style="margin: 0px; padding: 5px 0px; font-size: 14px; font-family: Tahoma, Helvetica, Arial, 宋体, sans-serif; line-height: 25.2000007629395px; widows: 1;">我们来运行下这段代码，然后将当前目录下的sample.txt文件修改一下，看下这个程序是否能察觉这个更新。</p><p style="margin: 0px; padding: 5px 0px; font-size: 14px; font-family: Tahoma, Helvetica, Arial, 宋体, sans-serif; line-height: 25.2000007629395px; widows: 1;"></p><div style="border-left-color: rgb(0, 153, 204); border-left-width: 1px; border-left-style: solid; padding: 0px 3px; margin: 3px auto 0px; width: 640px; clear: both; font-size: 14px; border-top-color: rgb(0, 153, 204); border-top-width: 1px; border-top-style: solid; border-right-color: rgb(0, 153, 204); border-right-width: 1px; border-right-style: solid; line-height: 25.2000007629395px; font-family: Tahoma, Helvetica, Arial, 宋体, sans-serif; widows: 1; background-color: rgb(242, 246, 251); background-position: initial initial; background-repeat: initial initial;"><span style="float: right; line-height: 25.2000007629395px; font-size: 14px;"><a style="color: rgb(51, 51, 51); cursor: pointer;"><u>复制代码</u></a></span>代码如下:</div><div style="border: 1px solid rgb(0, 153, 204); padding: 0px 3px 0px 5px; margin: 0px auto 3px; width: 638px; clear: both; font-size: 14px; line-height: 25.2000007629395px; font-family: Tahoma, Helvetica, Arial, 宋体, sans-serif; widows: 1; background-color: rgb(221, 237, 251); background-position: initial initial; background-repeat: initial initial;"><br/>
Report any file changed within next 1 minute...
<p style="margin: 0px; padding: 5px 0px; font-size: 14px;"></p><p style="margin: 0px; padding: 5px 0px; font-size: 14px;">sample.txt<br/></p></div><p style="margin: 0px; padding: 5px 0px; font-size: 14px; font-family: Tahoma, Helvetica, Arial, 宋体, sans-serif; line-height: 25.2000007629395px; widows: 1;"></p><p style="margin: 0px; padding: 5px 0px; font-size: 14px; font-family: Tahoma, Helvetica, Arial, 宋体, sans-serif; line-height: 25.2000007629395px; widows: 1;">当我们修改了这个文件的时候，程序会提示说文件被修改了。我们可以用这个功能来监视不同文件的更新，然后执行相应的任务。当然我们也可以只注册文件新建或者删除的操作。</p><p style="margin: 0px; padding: 5px 0px; font-size: 14px; font-family: Tahoma, Helvetica, Arial, 宋体, sans-serif; line-height: 25.2000007629395px; widows: 1;"><strong>总结</strong></p><p style="margin: 0px; padding: 5px 0px; font-size: 14px; font-family: Tahoma, Helvetica, Arial, 宋体, sans-serif; line-height: 25.2000007629395px; widows: 1;">有了lambda表达式和方法引用后，像字符串及文件的操作，创建自定义比较器这些常见的任务都变得更简单也更简洁了。匿名内部类也变得优雅起来了，而可变性就像日出后的晨雾一样，也消失得无影无踪了。使用这种新风格进行编码还有一个福利，就是你可以使用JDK的新设施来高效地遍历庞大的目录。</p><p style="margin: 0px; padding: 5px 0px; font-size: 14px; font-family: Tahoma, Helvetica, Arial, 宋体, sans-serif; line-height: 25.2000007629395px; widows: 1;">现在你已经知道如何创建lambda表达式并把它传递给方法了。下一章我们会介绍如何使用函数式接口及lambda表达式进行软件的设计。</p><div style="padding: 0px 0px 20px; margin: 0px; clear: both; overflow: hidden; width: 680px; line-height: 25.2000007629395px; font-size: 14px; font-family: Tahoma, Helvetica, Arial, 宋体, sans-serif; widows: 1;"><h4 style="margin: 0px; padding: 0px; font-size: 14px; color: rgb(0, 102, 153);">您可能感兴趣的文章:</h4><ul style="margin: 0px; padding: 0px; list-style: none;"><li style="margin: 0px; padding: 0px 0px 0px 20px; list-style: none; font-size: 14px; line-height: 24px; color: rgb(0, 102, 153); text-align: left; display: block; background-image: url(&quot;&quot;); background-position: 8px 50%; background-repeat: no-repeat no-repeat;"><a href="http://www.jb51.net/article/55668.htm" style="text-decoration: none; color: rgb(255, 102, 0); font-size: 14px;" target="_blank" title="Java函数式编程(十一)：遍历目录">Java函数式编程(十一)：遍历目录</a></li><li style="margin: 0px; padding: 0px 0px 0px 20px; list-style: none; font-size: 14px; line-height: 24px; color: rgb(0, 102, 153); text-align: left; display: block; background-image: url(&quot;&quot;); background-position: 8px 50%; background-repeat: no-repeat no-repeat;"><a href="http://www.jb51.net/article/55665.htm" style="text-decoration: none; color: rgb(255, 102, 0); font-size: 14px;" target="_blank" title="Java函数式编程(十)：收集器">Java函数式编程(十)：收集器</a></li><li style="margin: 0px; padding: 0px 0px 0px 20px; list-style: none; font-size: 14px; line-height: 24px; color: rgb(0, 102, 153); text-align: left; display: block; background-image: url(&quot;&quot;); background-position: 8px 50%; background-repeat: no-repeat no-repeat;"><a href="http://www.jb51.net/article/55664.htm" style="text-decoration: none; color: rgb(255, 102, 0); font-size: 14px;" target="_blank" title="Java函数式编程(九)：Comparator">Java函数式编程(九)：Comparator</a></li><li style="margin: 0px; padding: 0px 0px 0px 20px; list-style: none; font-size: 14px; line-height: 24px; color: rgb(0, 102, 153); text-align: left; display: block; background-image: url(&quot;&quot;); background-position: 8px 50%; background-repeat: no-repeat no-repeat;"><a href="http://www.jb51.net/article/55661.htm" style="text-decoration: none; color: rgb(255, 102, 0); font-size: 14px;" target="_blank" title="Java函数式编程(八)：字符串及方法引用">Java函数式编程(八)：字符串及方法引用</a></li><li style="margin: 0px; padding: 0px 0px 0px 20px; list-style: none; font-size: 14px; line-height: 24px; color: rgb(0, 102, 153); text-align: left; display: block; background-image: url(&quot;&quot;); background-position: 8px 50%; background-repeat: no-repeat no-repeat;"><a href="http://www.jb51.net/article/55659.htm" style="text-decoration: none; color: rgb(255, 102, 0); font-size: 14px;" target="_blank" title="Java函数式编程(七)：MapReduce">Java函数式编程(七)：MapReduce</a></li><li style="margin: 0px; padding: 0px 0px 0px 20px; list-style: none; font-size: 14px; line-height: 24px; color: rgb(0, 102, 153); text-align: left; display: block; background-image: url(&quot;&quot;); background-position: 8px 50%; background-repeat: no-repeat no-repeat;"><a href="http://www.jb51.net/article/55658.htm" style="text-decoration: none; color: rgb(255, 102, 0); font-size: 14px;" target="_blank" title="Java函数式编程(六)：Optional">Java函数式编程(六)：Optional</a></li><li style="margin: 0px; padding: 0px 0px 0px 20px; list-style: none; font-size: 14px; line-height: 24px; color: rgb(0, 102, 153); text-align: left; display: block; background-image: url(&quot;&quot;); background-position: 8px 50%; background-repeat: no-repeat no-repeat;"><a href="http://www.jb51.net/article/55630.htm" style="text-decoration: none; color: rgb(255, 102, 0); font-size: 14px;" target="_blank" title="Java函数式编程(五)：闭包">Java函数式编程(五)：闭包</a></li><li style="margin: 0px; padding: 0px 0px 0px 20px; list-style: none; font-size: 14px; line-height: 24px; color: rgb(0, 102, 153); text-align: left; display: block; background-image: url(&quot;&quot;); background-position: 8px 50%; background-repeat: no-repeat no-repeat;"><a href="http://www.jb51.net/article/55629.htm" style="text-decoration: none; color: rgb(255, 102, 0); font-size: 14px;" target="_blank" title="Java函数式编程(四)：在集合中查找元素">Java函数式编程(四)：在集合中查找元素</a></li><li style="margin: 0px; padding: 0px 0px 0px 20px; list-style: none; font-size: 14px; line-height: 24px; color: rgb(0, 102, 153); text-align: left; display: block; background-image: url(&quot;&quot;); background-position: 8px 50%; background-repeat: no-repeat no-repeat;"><a href="http://www.jb51.net/article/55627.htm" style="text-decoration: none; color: rgb(255, 102, 0); font-size: 14px;" target="_blank" title="Java函数式编程(三)：列表的转化">Java函数式编程(三)：列表的转化</a></li><li style="margin: 0px; padding: 0px 0px 0px 20px; list-style: none; font-size: 14px; line-height: 24px; color: rgb(0, 102, 153); text-align: left; display: block; background-image: url(&quot;&quot;); background-position: 8px 50%; background-repeat: no-repeat no-repeat;"><a href="http://www.jb51.net/article/55625.htm" style="text-decoration: none; color: rgb(255, 102, 0); font-size: 14px;" target="_blank" title="Java函数式编程(二)：集合的使用">Java函数式编程(二)：集合的使用</a></li><li style="margin: 0px; padding: 0px 0px 0px 20px; list-style: none; font-size: 14px; line-height: 24px; color: rgb(0, 102, 153); text-align: left; display: block; background-image: url(&quot;&quot;); background-position: 8px 50%; background-repeat: no-repeat no-repeat;"><a href="http://www.jb51.net/article/55622.htm" style="text-decoration: none; color: rgb(255, 102, 0); font-size: 14px;" target="_blank" title="Java函数式编程(一)：你好，Lambda表达式">Java函数式编程(一)：你好，Lambda表达式</a></li><li style="list-style: none"><br/><div style="color:gray"><small>来源： &lt;<a href="http://www.jb51.net/article/55669.htm">http://www.jb51.net/article/55669.htm</a><small>&gt;</small></small></div><small><small> </small></small></li></ul></div></span>
</div></body></html> 