<html>
<head>
  <title>AOP注解日志处理简单理解_lakersuperstar_新浪博客.html</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/306387 (zh-CN, DDL); Windows/10.0.0 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="667"/>
<h1>AOP注解日志处理简单理解_lakersuperstar_新浪博客.html</h1>

<div>
<span><p><span style="font-size: 12pt; font-family: 宋体;"><span style="color: rgb(255, 0, 0);">理解注解：</span></span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US">1</span><span style="font-size: 12pt; font-family: 宋体;">、首先注解是在<span lang="EN-US" xml:lang="EN-US">JDK5.0</span>及以后版本中引入的。他可以用于创建文档，跟踪代码中的依赖性，甚至执行基本的编译时检查，而且还可以作为在<span lang="EN-US" xml:lang="EN-US">spring</span>框架中进行注解试注入<span lang="EN-US" xml:lang="EN-US">Bean</span>属性，用来减少写配置文件。注解是以<span lang="EN-US" xml:lang="EN-US">@+</span>注解名在代码中存在的，根据注解参数的个数，我们可以将注解分为：标记注解，单值注解、完整注解三类。他们都不会直接影响到程序的语义，只是作为注解存在，可以通过反射机制编程实现对这些元数据的访问。另外，你可以在编译时选择代码哩的注释是否只存在于源代码级，或者它也能在<span lang="EN-US" xml:lang="EN-US">class</span>文件中出现。</span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US"><span>  </span></span> <span style="font-size: 12pt; font-family: 宋体;">在这里所说的元数据作用可以大致分为三类：生成文档，编译时检查，跟踪代码的依赖性，代替已有的配置文件。</span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US">2</span><span style="font-size: 12pt; font-family: 宋体;">、注释的<span lang="EN-US" xml:lang="EN-US">3</span>中基本类型</span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US"><span> </span> a</span><span style="font-size: 12pt; font-family: 宋体;">、标记注释<span lang="EN-US" xml:lang="EN-US"><span>   </span> --</span>没有变量，只有名称标示 例如：<span lang="EN-US" xml:lang="EN-US">@annotation</span></span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US"><span> </span> b</span><span style="font-size: 12pt; font-family: 宋体;">、单一值注释<span lang="EN-US" xml:lang="EN-US"><span> </span> --</span>在标记注释的基础上提供一段数据。 例如：<span lang="EN-US" xml:lang="EN-US">@annotation(&quot;data&quot;)</span></span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US"><span> </span> c</span><span style="font-size: 12pt; font-family: 宋体;">、完整注释<span lang="EN-US" xml:lang="EN-US"><span>   </span> --</span>可以包括多个数据成员，每个数据成员由名称和值构成</span></p><p><span style="font-size: 12pt; font-family: 宋体;">例如：<span lang="EN-US" xml:lang="EN-US">@annotation(val1=&quot;data1&quot;,val2=&quot;data2&quot;)</span></span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US">3</span><span style="font-size: 12pt; font-family: 宋体;">、<span lang="EN-US" xml:lang="EN-US">java</span>中提供了<span lang="EN-US" xml:lang="EN-US">3</span>个内置注释类型</span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US">a</span><span style="font-size: 12pt; font-family: 宋体;">、<span lang="EN-US" xml:lang="EN-US">override,</span>这个大家都不陌生，他是只能用在方法上，对方法的重写</span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US"><span>  </span></span> <span style="font-size: 12pt; font-family: 宋体;">作用：可以保证编译时<span lang="EN-US" xml:lang="EN-US">Override</span>函数的声明正确性</span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US"><span>  </span></span> <span style="font-size: 12pt; font-family: 宋体;">用法：<span lang="EN-US" xml:lang="EN-US">@override</span></span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US">b</span><span style="font-size: 12pt; font-family: 宋体;">、<span lang="EN-US" xml:lang="EN-US">Deprecated</span> 同样只能作用于方法</span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US"><span>  </span></span> <span style="font-size: 12pt; font-family: 宋体;">作用：对不应在使用的方法进行注解</span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US"><span>  </span></span> <span style="font-size: 12pt; font-family: 宋体;">用法：<span lang="EN-US" xml:lang="EN-US">@Deprecated</span> 并且他必须得和这个函数放在同一行，现在不在经常使用</span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US">c</span><span style="font-size: 12pt; font-family: 宋体;">、<span lang="EN-US" xml:lang="EN-US">SuperssWarnings<span> </span></span> 可以注释一段代码</span></p><p><span style="font-size: 12pt; font-family: 宋体;">作用：关闭特定的告警信息，</span></p><p><span style="font-size: 12pt; font-family: 宋体;">用法：<span lang="EN-US" xml:lang="EN-US">@SuperssWarnings</span> （<span lang="EN-US" xml:lang="EN-US">value={&quot;unchecked&quot;}</span>）代码</span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US"><span>  </span></span> <span style="font-size: 12pt; font-family: 宋体;">这三个只是简单的注解类型</span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US">4</span><span style="font-size: 12pt; font-family: 宋体;">、在<span lang="EN-US" xml:lang="EN-US">java</span>中最重要的是元注解，元注解是什么呢？</span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US"><span>  </span></span> <span style="font-size: 12pt; font-family: 宋体;">元注解是用来描述注解的注解，就是用来注解其他的注解，为什么会出现它呢，因为我们在项目中要用到自定义的注解，所以这些自定义的注解就是要用这些元注解来注解的。</span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US"><span>  </span></span> <span style="font-size: 12pt; font-family: 宋体;">要写一个自定义的注解<span lang="EN-US" xml:lang="EN-US">,</span>必须通过<span lang="EN-US" xml:lang="EN-US">@interface</span>关键字来定义，在你这个类之前，就需要通过这些个元注解来描述该注解的使用范围（<span lang="EN-US" xml:lang="EN-US">@Target</span>）、生命周期<span lang="EN-US" xml:lang="EN-US">(@Retention)</span>及其他。</span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US"><span>  </span> a</span><span style="font-size: 12pt; font-family: 宋体;">、<span lang="EN-US" xml:lang="EN-US">@Target<span> </span></span> 表示该注释可以用于什么地方，可用的参数<span lang="EN-US" xml:lang="EN-US">ElementType</span>参数包括<span lang="EN-US" xml:lang="EN-US">:</span></span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US"><span>     </span> CONSTRUCTOR:</span><span style="font-size: 12pt; font-family: 宋体;">说明此注解只能用于构造器</span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US"><span>     </span> FIELD</span><span style="font-size: 12pt; font-family: 宋体;">：说明只能用于域的声明</span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US"><span>     </span> LOCAL_VARIABLE:</span><span style="font-size: 12pt; font-family: 宋体;">局部变量声明</span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US"><span>     </span> METHOD:</span><span style="font-size: 12pt; font-family: 宋体;">方法声明</span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US"><span>     </span> PACKAGE:</span><span style="font-size: 12pt; font-family: 宋体;">包声明</span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US"><span>     </span> PARAMETER:</span><span style="font-size: 12pt; font-family: 宋体;">参数声明</span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US"><span>     </span> TYPE</span><span style="font-size: 12pt; font-family: 宋体;">：类、接口（包括注解类型）或者是<span lang="EN-US" xml:lang="EN-US">enum</span>声明</span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US"><span>  </span> b</span><span style="font-size: 12pt; font-family: 宋体;">、<span lang="EN-US" xml:lang="EN-US">@Retention</span> 表示需要在什么级别保存该注释信息。可选的<span lang="EN-US" xml:lang="EN-US">RetentionPolicy</span>参数包括</span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US"><span>     </span> SOURCE:</span><span style="font-size: 12pt; font-family: 宋体;">注释将被编译器丢掉</span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US"><span>     </span> CLASS</span><span style="font-size: 12pt; font-family: 宋体;">：注释在<span lang="EN-US" xml:lang="EN-US">class</span>文件中可用，但会被<span lang="EN-US" xml:lang="EN-US">vm</span>丢弃</span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US"><span>     </span> RUNTIME</span><span style="font-size: 12pt; font-family: 宋体;">：<span lang="EN-US" xml:lang="EN-US">VM</span>将在运行时也保障注释，因此可以通过反射机制读取注释的信息。</span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US"><span>  </span> c</span><span style="font-size: 12pt; font-family: 宋体;">、<span lang="EN-US" xml:lang="EN-US">@Documented<span> </span></span> 将注释包含在<span lang="EN-US" xml:lang="EN-US">JavaDoc</span>中</span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US"><span>  </span> d</span><span style="font-size: 12pt; font-family: 宋体;">、<span lang="EN-US" xml:lang="EN-US">@Inheried</span> 允许子类继承父类中的注释。</span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US"> </span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US">5</span><span style="font-size: 12pt; font-family: 宋体;">、写个简单的自定义注解例子：</span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US">@Target({ElementType.TYPE,ElementType.METHOD})</span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US">@Retention(RetentionPolicy.RUNTIME)</span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US">public @interface AnnotationName {</span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US"> </span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US"><span>   </span> <span> </span>String value();</span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US">}</span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US">//</span><span style="font-size: 12pt; font-family: 宋体;">这个注解只能用在类、接口或者是<span lang="EN-US" xml:lang="EN-US">enum</span>、方法名、之前，并且在运行时保持注解</span></p><p><span style="font-size: 12pt; font-family: 宋体;">使用这个注解：</span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US">@AnnotationName(value=&quot;test&quot;)</span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US">public class Test {</span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US"><span>   </span> public Test(){<span>   </span></span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US"><span>   </span> }</span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US">}</span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US">6</span><span style="font-size: 12pt; font-family: 宋体;">、如果你要记录日志，那么这个注解中的值你可以写成你此刻运行的方法，在这里就有问题出现了，你注解到这里你怎么去读取你注解里的<span lang="EN-US" xml:lang="EN-US">value</span>值呢，</span></p><p><span style="font-size: 12pt; font-family: 宋体;">这里就用到了注解处理器，注解处理器其实就是一段处理自己编写的注解类的代码而已。并不用太多复杂的概念或者技术可以使用反射的方法去读取注解里边的值：在这里就必须将<span lang="EN-US" xml:lang="EN-US">RetentionPolicy</span>指定为<span lang="EN-US" xml:lang="EN-US">RUNTIME</span></span></p><p><span style="font-size: 12pt; font-family: 宋体;">例子：</span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US">A</span><span style="font-size: 12pt; font-family: 宋体;">、这是你执行的那个注解处理器</span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US">public class TestExcute<span>  </span> {</span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US"><span>   </span> public void getLog(ProceedingJoinPoint joinPoint) throws Throwable{</span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US"><span>      </span> System.out.println(&quot;****************************</span><span style="font-size: 12pt; font-family: 宋体;">注解解释器执行开始<span lang="EN-US" xml:lang="EN-US">*********************************&quot;);</span></span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US"><span>      </span> <span style="color: rgb(255, 0, 0);">//</span></span><span style="font-size: 12pt; font-family: 宋体;"><span style="color: rgb(255, 0, 0);">获取目标对象对应的类名</span></span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US"><span>      </span> System.out.println(&quot;</span><span style="font-size: 12pt; font-family: 宋体;">应用注解的类名：<span lang="EN-US" xml:lang="EN-US">&quot;+joinPoint.getTarget().getClass());</span></span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US"><span>      </span> <span style="color: rgb(255, 0, 0);">//</span></span><span style="font-size: 12pt; font-family: 宋体;"><span style="color: rgb(255, 0, 0);">获取实现类继承的接口名</span></span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US"><span>      </span> @SuppressWarnings(&quot;rawtypes&quot;)</span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US"><span>      </span> Class[] c = joinPoint.getTarget().getClass().getInterfaces();</span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US"><span>      </span> System.out.println(&quot;</span><span style="font-size: 12pt; font-family: 宋体;">注解对象所实现的接口名：<span lang="EN-US" xml:lang="EN-US">&quot;+c[0]);</span></span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US"><span>      </span> <span style="color: rgb(255, 0, 0);">//</span></span><span style="font-size: 12pt; font-family: 宋体; color: rgb(255, 0, 0);">获取到了注解在这个<span lang="EN-US" xml:lang="EN-US">service</span>实现类上的<span lang="EN-US" xml:lang="EN-US">annotation</span></span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US"><span>      </span> Annotation[] a = joinPoint.getTarget().getClass().getAnnotations();</span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US"><span>      </span> <span style="color: rgb(255, 0, 0);">//</span></span><span style="font-size: 12pt; font-family: 宋体;"><span style="color: rgb(255, 0, 0);">获取这个类上的注解的个数</span></span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US"><span>      </span> System.out.println(&quot;</span><span style="font-size: 12pt; font-family: 宋体;">应用注解类上的注解个数：<span lang="EN-US" xml:lang="EN-US">&quot;+a.length);</span></span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US"><span>      </span> <span style="color: rgb(255, 0, 0);">//</span></span><span style="font-size: 12pt; font-family: 宋体; color: rgb(255, 0, 0);">判断这个类上面的注释是否是<span lang="EN-US" xml:lang="EN-US">AnnotationName</span>这个自定义的注解，如果是返回这个注解，如果不是返回<span lang="EN-US" xml:lang="EN-US">null</span></span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US"><span>      </span> if(joinPoint.getTarget().getClass().getAnnotation(AnnotationName.class)!=null){</span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US"><span>          </span> <span style="color: rgb(255, 0, 0);">//</span></span><span style="font-size: 12pt; font-family: 宋体;"><span style="color: rgb(255, 0, 0);">获取到这个类上的注解</span></span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US"><span>          </span> AnnotationName anns = joinPoint.getTarget().getClass().getAnnotation(AnnotationName.class);</span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US"><span>         </span> <span> <span style="color: rgb(255, 0, 0);"> </span></span><span style="color: rgb(255, 0, 0);">//</span></span><span style="font-size: 12pt; font-family: 宋体;"><span style="color: rgb(255, 0, 0);">输出这个类上的注解的值</span></span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US"><span>          </span> System.out.println(&quot;</span><span style="font-size: 12pt; font-family: 宋体;">注释在实现类上的<span lang="EN-US" xml:lang="EN-US">annotation</span>：<span lang="EN-US" xml:lang="EN-US">&quot;+anns.value());</span></span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US"><span>      </span> }</span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US"><span>      </span> <span style="color: rgb(255, 0, 0);">//</span></span><span style="font-size: 12pt; font-family: 宋体;"><span style="color: rgb(255, 0, 0);">判断这个接口上是否存在此注解</span></span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US"><span>      </span> if(c[0].getAnnotation(AnnotationName.class)!=null){</span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US"><span>          </span> AnnotationName an = (AnnotationName) c[0].getAnnotation(AnnotationName.class);</span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US"><span>          </span> System.out.println(&quot;</span><span style="font-size: 12pt; font-family: 宋体;">注解对象所实现接口上的注解值：<span lang="EN-US" xml:lang="EN-US">&quot;+an.value());</span></span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US"><span>      </span> }</span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US"><span>      </span> <span style="color: rgb(255, 0, 0);">//</span></span><span style="font-size: 12pt; font-family: 宋体;"><span style="color: rgb(255, 0, 0);">获取目标对象上正在执行的方法名</span></span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US"><span>      </span> String methodString = joinPoint.getSignature().getName();</span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US"><span>      </span> System.out.println(&quot;</span><span style="font-size: 12pt; font-family: 宋体;">目标对象上正在执行的方法名：<span lang="EN-US" xml:lang="EN-US">&quot;+methodString);</span></span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US"><span>      </span> <span style="color: rgb(255, 0, 0);">//</span></span><span style="font-size: 12pt; font-family: 宋体;"><span style="color: rgb(255, 0, 0);">获取到这个类上面的方法全名</span></span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US"><span>      </span> Method meths[] = joinPoint.getSignature().getDeclaringType().getMethods();</span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US"><span>      </span> System.out.println(&quot;</span><span style="font-size: 12pt; font-family: 宋体;">方法上面的全名：<span lang="EN-US" xml:lang="EN-US">&quot;+meths[0]);</span></span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US"><span>      </span> <span style="color: rgb(255, 0, 0);">//</span></span><span style="font-size: 12pt; font-family: 宋体;"><span style="color: rgb(255, 0, 0);">获取到这个类上面的方法上面的注释</span></span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US"><span>      </span> Annotation[] anns = meths[0].getDeclaredAnnotations();</span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US"><span>      </span> System.out.println(&quot;</span><span style="font-size: 12pt; font-family: 宋体;">正在执行方法上面的注释：<span lang="EN-US" xml:lang="EN-US">&quot;+((AnnotationName)anns[0]).value());</span></span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US"><span>      </span> <span style="color: rgb(255, 0, 0);">//</span></span><span style="font-size: 12pt; font-family: 宋体;"><span style="color: rgb(255, 0, 0);">让你注释的那个方法执行</span></span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US"><span>      </span> joinPoint.proceed();</span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US"><span>      </span> <span style="color: rgb(255, 0, 0);">//</span></span><span style="font-size: 12pt; font-family: 宋体;"><span style="color: rgb(255, 0, 0);">完毕</span></span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US"><span>      </span> System.out.println(&quot;****************************</span><span style="font-size: 12pt; font-family: 宋体;">注解解释器执行完毕<span lang="EN-US" xml:lang="EN-US">*********************************&quot;);</span></span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US"><span>   </span> }</span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US">}</span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US">B</span><span style="font-size: 12pt; font-family: 宋体;">、这个注解解释器所使用的是<span lang="EN-US" xml:lang="EN-US">jdk</span>自己的代理类生成机制，所以你所要记录的类必须是继承自一个接口，因为他这个生成的代理类可以理解为接口和你这个实现类之间的一个类，所以这个记录的类必须是要实现一个接口</span></p><p><span style="font-size: 12pt; font-family: 宋体;">接口：</span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US">@AnnotationName(value=&quot;Test1</span><span style="font-size: 12pt; font-family: 宋体;">测试<span lang="EN-US" xml:lang="EN-US">interface&quot;)</span></span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US">public interface Test1 {</span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US"><span>   </span> @AnnotationName(value=&quot;Test1</span><span style="font-size: 12pt; font-family: 宋体;">测试<span lang="EN-US" xml:lang="EN-US">testAspect&quot;)</span></span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US"><span>   </span> public void testAspect();</span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US">}</span></p><p><span style="font-size: 12pt; font-family: 宋体;">实现类：</span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US">@AnnotationName(value=&quot;Test</span><span style="font-size: 12pt; font-family: 宋体;">测试业务<span lang="EN-US" xml:lang="EN-US">Test2&quot;)</span></span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US">public class Test2 implements Test1{</span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US"><span>   </span> @Override</span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US"><span>   </span> public void testAspect() {</span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US"><span>      </span> // TODO Auto-generated method stub</span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US"><span>      </span> System.out.println(&quot;Test2 is excuting</span><span style="font-size: 12pt; font-family: 宋体;">。。。。。。。。<span lang="EN-US" xml:lang="EN-US">&quot;);</span></span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US"><span>   </span> }</span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US">}</span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US">C</span><span style="font-size: 12pt; font-family: 宋体;">、<span lang="EN-US" xml:lang="EN-US">Action</span>：</span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US">public class Test extends ActionSupport{</span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US"> </span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US"><span>   </span> private static final long serialVersionUID = 1L;</span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US"><span>   </span> private Test1 test2;</span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US"><span>   </span></span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US"><span>   </span> public Test1 getTest2() {</span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US"><span>      </span> return test2;</span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US"><span>   </span> }</span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US"> </span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US"><span>   </span> public void setTest2(Test1 test2) {</span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US"><span>      </span> this.test2 = test2;</span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US"><span>   </span> }</span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US"> </span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US"><span>   </span> public void getTest(){</span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US"><span>      </span> test2.testAspect();</span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US"><span>      </span> System.out.println(&quot;=========================</span><span style="font-size: 12pt; font-family: 宋体;">执行<span lang="EN-US" xml:lang="EN-US">Action======================&quot;);</span></span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US"><span>   </span> }</span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US"><span>  </span></span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US"> </span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US">}</span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US">D</span><span style="font-size: 12pt; font-family: 宋体;">、在<span lang="EN-US" xml:lang="EN-US">spring</span>配置文件中的配置：</span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US">&lt;!--</span> <span style="font-size: 12pt; font-family: 宋体;">打开<span lang="EN-US" xml:lang="EN-US">AOP</span>的拦截功能<span lang="EN-US" xml:lang="EN-US">,proxy-target-class:</span>是用来控制注入的时实现类还是接口，默认是<span lang="EN-US" xml:lang="EN-US">false</span>表示只能注入接口，<span lang="EN-US" xml:lang="EN-US">true</span>：表示可以用类来注入<span lang="EN-US" xml:lang="EN-US">--&gt;</span></span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US">&lt;aop:aspectj-autoproxy proxy-target-class=&quot;false&quot;/&gt;<span>          </span></span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US">&lt;aop:config&gt;</span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US">&lt;!--</span> <span style="font-size: 12pt; font-family: 宋体;">声明一个切面 <span lang="EN-US" xml:lang="EN-US">--&gt;</span></span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US">&lt;aop:aspect id=&quot;testExcuteAspect&quot; ref=&quot;testExcute&quot;&gt;</span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US">&lt;!--</span> <span style="font-size: 12pt; font-family: 宋体;">声明一个装备，是在什么时候执行日志处理 <span lang="EN-US" xml:lang="EN-US">--&gt;</span></span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US">&lt;!--</span> <span style="font-size: 12pt; font-family: 宋体;">声明一个切入点<span lang="EN-US" xml:lang="EN-US">,</span></span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US">expression:</span> <span style="font-size: 12pt; font-family: 宋体;">第一个<span lang="EN-US" xml:lang="EN-US">*</span>表示：通配符，表示返回任何类型，</span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US"><span>                               </span></span> <span style="font-size: 12pt; font-family: 宋体;">第二个<span lang="EN-US" xml:lang="EN-US">*</span>表示：通配符，表示这个包下的任意类</span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US"><span>                               </span></span> <span style="font-size: 12pt; font-family: 宋体;">第三个<span lang="EN-US" xml:lang="EN-US">*</span>表示：通配符，表示这个类下的方法可以有<span lang="EN-US" xml:lang="EN-US">0</span>个或多个参数</span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US"><span>           </span> (..)</span><span style="font-size: 12pt; font-family: 宋体;">：表示这个包下的所有子包<span lang="EN-US" xml:lang="EN-US"><span>                                       </span></span></span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US"><span> </span>--&gt;</span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US">&lt;aop:pointcut expression=&quot;execution(* com.ckpt.logPackage.*.*(..))&quot; id=&quot;logTest&quot; /&gt;</span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US">&lt;aop:around<span> </span> method=&quot;getLog&quot; pointcut-ref=&quot;logTest&quot; /&gt;</span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US">&lt;/aop:aspect&gt;</span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US">&lt;/aop:config&gt;</span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US">&lt;bean id=&quot;testExcute&quot; class=&quot;com.ckpt.logPackage.TestExcute&quot; scope=&quot;prototype&quot;&gt;&lt;/bean&gt;</span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US">&lt;bean id=&quot;test&quot; class=&quot;com.ckpt.Action.Test&quot; scope=&quot;prototype&quot;&gt;</span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US">&lt;property name=&quot;test2&quot; ref=&quot;test2&quot;&gt;&lt;/property&gt;</span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US">&lt;/bean&gt;</span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US">&lt;bean id=&quot;test2&quot; class=&quot;com.ckpt.logPackage.Test2&quot; scope=&quot;prototype&quot;&gt;&lt;/bean&gt;</span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US">E</span><span style="font-size: 12pt; font-family: 宋体;">、<span lang="EN-US" xml:lang="EN-US">struts2</span>配置文件：</span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US">&lt;action name=&quot;test&quot; class=&quot;test&quot; method=&quot;getTest&quot; &gt;</span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US">&lt;result type=&quot;plainText&quot;&gt;&lt;/result&gt;</span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US">&lt;/action&gt;</span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US">F</span><span style="font-size: 12pt; font-family: 宋体;">、发布项目，在浏览器中直接访问<span lang="EN-US" xml:lang="EN-US">Action</span>打印出日志</span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US">7</span><span style="font-size: 12pt; font-family: 宋体;">、<span lang="EN-US" xml:lang="EN-US">ProceedingJoinPoint :</span>使用这个类取处理日志，只能处理环绕通知</span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US">ProceedingJoinPoint is only supported for around advice</span></p><p><span lang="EN-US" style="font-size: 12pt; font-family: 宋体;" xml:lang="EN-US"><span>  </span></span></p></span>
</div></body></html> 