<html>
<head>
  <title>ComboPooledDataSource和BasicDataSource和DriverM.html</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/306387 (zh-CN, DDL); Windows/10.0.0 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="519"/>
<h1>ComboPooledDataSource和BasicDataSource和DriverM.html</h1>

<div>
<span><a name="274"></a><h1>ComboPooledDataSource和BasicDataSource和DriverManagerDataSource</h1><div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;"><div><p>ComboPooledDataSource、BasicDataSource、DriverManagerDataSource、Tomcat_JDBC、proxool</p><p><br/></p><p><br/></p><p>Spring在第三方依赖包中包含了两个数据源的实现类包，其一是Apache的DBCP，其二是 C3P0。可以在Spring配置文件中利用这两者中任何一个配置数据源。</p><p> DBCP数据源 </p><p>    DBCP类包位于 /lib/jakarta-commons/commons-dbcp.jar，DBCP是一个依赖 Jakarta commons-pool对象池机制的数据库连接池，所以在类路径下还必须包括/lib/jakarta- commons/commons-pool.jar。下面是使用DBCP配置MySql数据源的配置片断：</p><p>xml 代码</p><p>&lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot;        </p><p>        destroy-method=&quot;close&quot;&gt;        </p><p>    &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot; /&gt;       </p><p>    &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3309/sampledb&quot; /&gt;       </p><p>    &lt;property name=&quot;username&quot; value=&quot;root&quot; /&gt;       </p><p>    &lt;property name=&quot;password&quot; value=&quot;1234&quot; /&gt;       </p><p>bean&gt;   </p><p>BasicDataSource提供了close()方法关闭数据源，所以必须设定destroy-method=”close”属性， 以便Spring容器关闭时，数据源能够正常关闭。除以上必须的数据源属性外，还有一些常用的属性： </p><p>    defaultAutoCommit：设置从数据源中返回的连接是否采用自动提交机制，默认值为 true； </p><p>    defaultReadOnly：设置数据源是否仅能执行只读操作， 默认值为 false； </p><p>    maxActive：最大连接数据库连接数，设置为0时，表示没有限制； </p><p>    maxIdle：最大等待连接中的数量，设置为0时，表示没有限制； </p><p>    maxWait：最大等待秒数，单位为毫秒， 超过时间会报出错误信息； </p><p>    validationQuery：用于验证连接是否成功的查询SQL语句，SQL语句必须至少要返回一行数据， 如你可以简单地设置为：“select count(*) from user”； </p><p>    removeAbandoned：是否自我中断，默认是 false ； </p><p>    removeAbandonedTimeout：几秒后数据连接会自动断开，在removeAbandoned为true，提供该值； </p><p>    logAbandoned：是否记录中断事件， 默认为 false； </p><p>C3P0数据源 </p><p>    C3P0是一个开放源代码的JDBC数据源实现项目，它在lib目录中与Hibernate一起发布，实现了JDBC3和JDBC2扩展规范说明的 Connection 和Statement 池。C3P0类包位于/lib/c3p0/c3p0-0.9.0.4.jar。下面是使用C3P0配置一个 oracle数据源：</p><p>xml 代码</p><p>&lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;        </p><p>        destroy-method=&quot;close&quot;&gt;       </p><p>    &lt;property name=&quot;driverClass&quot; value=&quot; oracle.jdbc.driver.OracleDriver &quot;/&gt;       </p><p>    &lt;property name=&quot;jdbcUrl&quot; value=&quot; jdbc:oracle:thin:@localhost:1521:ora9i &quot;/&gt;       </p><p>    &lt;property name=&quot;user&quot; value=&quot;admin&quot;/&gt;       </p><p>    &lt;property name=&quot;password&quot; value=&quot;1234&quot;/&gt;       </p><p>bean&gt;   </p><p>ComboPooledDataSource和BasicDataSource一样提供了一个用于关闭数据源的close()方法，这样我们就可以保证Spring容器关闭时数据源能够成功释放。 </p><p>    C3P0拥有比DBCP更丰富的配置属性，通过这些属性，可以对数据源进行各种有效的控制： </p><p>    acquireIncrement：当连接池中的连接用完时，C3P0一次性创建新连接的数目； </p><p>    acquireRetryAttempts：定义在从数据库获取新连接失败后重复尝试获取的次数，默认为30； </p><p>    acquireRetryDelay：两次连接中间隔时间，单位毫秒，默认为1000； </p><p>    autoCommitOnClose：连接关闭时默认将所有未提交的操作回滚。默认为false； </p><p>    automaticTestTable： C3P0将建一张名为Test的空表，并使用其自带的查询语句进行测试。如果定义了这个参数，那么属性preferredTestQuery将被忽略。你 不能在这张Test表上进行任何操作，它将中为C3P0测试所用，默认为null； </p><p>    breakAfterAcquireFailure：获取连接失败将会引起所有等待获取连接的线程抛出异常。但是数据源仍有效保留，并在下次调   用getConnection()的时候继续尝试获取连接。如果设为true，那么在尝试获取连接失败后该数据源将申明已断开并永久关闭。默认为 false； </p><p>    checkoutTimeout：当连接池用完时客户端调用getConnection()后等待获取新连接的时间，超时后将抛出SQLException，如设为0则无限期等待。单位毫秒，默认为0； </p><p>    connectionTesterClassName： 通过实现ConnectionTester或QueryConnectionTester的类来测试连接，类名需设置为全限定名。默认为 com.mchange.v2.C3P0.impl.DefaultConnectionTester； </p><p>    idleConnectionTestPeriod：隔多少秒检查所有连接池中的空闲连接，默认为0表示不检查； </p><p>    initialPoolSize：初始化时创建的连接数，应在minPoolSize与maxPoolSize之间取值。默认为3； </p><p>    maxIdleTime：最大空闲时间，超过空闲时间的连接将被丢弃。为0或负数则永不丢弃。默认为0； </p><p>    maxPoolSize：连接池中保留的最大连接数。默认为15； </p><p>    maxStatements：JDBC的标准参数，用以控制数据源内加载的PreparedStatement数量。但由于预缓存的Statement属 于单个Connection而不是整个连接池。所以设置这个参数需要考虑到多方面的因素，如果maxStatements与 maxStatementsPerConnection均为0，则缓存被关闭。默认为0； </p><p>    maxStatementsPerConnection：连接池内单个连接所拥有的最大缓存Statement数。默认为0； </p><p>    numHelperThreads：C3P0是异步操作的，缓慢的JDBC操作通过帮助进程完成。扩展这些操作可以有效的提升性能，通过多线程实现多个操作同时被执行。默认为3； </p><p>    preferredTestQuery：定义所有连接测试都执行的测试语句。在使用连接测试的情况下这个参数能显著提高测试速度。测试的表必须在初始数据源的时候就存在。默认为null； </p><p>    propertyCycle： 用户修改系统配置参数执行前最多等待的秒数。默认为300； </p><p>    testConnectionOnCheckout：因性能消耗大请只在需要的时候使用它。如果设为true那么在每个connection提交的时候都 将校验其有效性。建议使用idleConnectionTestPeriod或automaticTestTable </p><p>等方法来提升连接测试的性能。默认为false； </p><p>    testConnectionOnCheckin：如果设为true那么在取得连接的同时将校验连接的有效性。默认为false。 </p><p>读配置文件的方式引用属性： </p><p>&lt;bean id=&quot;propertyConfigurer&quot;      </p><p>        class=&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;&gt;       </p><p>    &lt;property name=&quot;location&quot; value=&quot;/WEB-INF/jdbc.properties&quot;/&gt;       </p><p>bean&gt;       </p><p>&lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot;        </p><p>        destroy-method=&quot;close&quot;&gt;       </p><p>    &lt;property name=&quot;driverClassName&quot; value=&quot;${jdbc.driverClassName}&quot; /&gt;       </p><p>    &lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot; /&gt;       </p><p>    &lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot; /&gt;       </p><p>    &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot; /&gt;       </p><p>bean&gt;    </p><p>    在jdbc.properties属性文件中定义属性值： </p><p>    jdbc.driverClassName= com.mysql.jdbc.Driver </p><p>    jdbc.url= jdbc:mysql://localhost:3309/sampledb </p><p>    jdbc.username=root </p><p>    jdbc.password=1234 </p><p>    提示 经常有开发者在${xxx}的前后不小心键入一些空格，这些空格字符将和变量合并后作为属性的值。如： 的属性配置项，在前后都有空格，被解析后，username的值为“ 1234 ”，这将造成最终的错误，因此需要特别小心。</p><p> 获取JNDI数据源 </p><p>    如果应用配置在高性能的应用服务器（如WebLogic或Websphere等）上，我们可能更希望使用应用服务器本身提供的数据源。应用服务器的数据源 使用JNDI开放调用者使用，Spring为此专门提供引用JNDI资源的JndiObjectFactoryBean类。下面是一个简单的配置：</p><p>xml 代码</p><p>&lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jndi.JndiObjectFactoryBean&quot;&gt;       </p><p>    &lt;property name=&quot;jndiName&quot; value=&quot;java:comp/env/jdbc/bbt&quot;/&gt;       </p><p>bean&gt;   </p><p>通过jndiName指定引用的JNDI数据源名称。 </p><p>    Spring 2.0为获取J2EE资源提供了一个jee命名空间，通过jee命名空间，可以有效地简化J2EE资源的引用。下面是使用jee命名空间引用JNDI数据源的配置： </p><p>xml 代码</p><p>&lt;beans xmlns=http://www.springframework.org/schema/beans     </p><p>xmlns:xsi=http://www.w3.org/2001/XMLSchema-instance     </p><p>xmlns:jee=http://www.springframework.org/schema/jee     </p><p>xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans      </p><p>http://www.springframework.org/schema/beans/spring-beans-2.0.xsd      </p><p>http://www.springframework.org/schema/jee     </p><p>http://www.springframework.org/schema/jee/spring-jee-2.0.xsd&quot;&gt;       </p><p>&lt;jee:jndi-lookup id=&quot;dataSource&quot; jndi-name=&quot; java:comp/env/jdbc/bbt&quot;/&gt;       </p><p>beans&gt;   </p><p>Spring的数据源实现类 </p><p>    Spring本身也提供了一个简单的数据源实现类DriverManagerDataSource ，它位于org.springframework.jdbc.datasource包中。这个类实现了javax.sql.DataSource接口，但 它并没有提供池化连接的机制，每次调用getConnection()获取新连接时，只是简单地创建一个新的连接。因此，这个数据源类比较适合在单元测试 或简单的独立应用中使用，因为它不需要额外的依赖类。 </p><p>     下面，我们来看一下DriverManagerDataSource的简单使用：当然，我们也可以通过配置的方式直接使用DriverManagerDataSource。</p><p>java 代码</p><p>DriverManagerDataSource ds = new DriverManagerDataSource ();       </p><p>ds.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;);       </p><p>ds.setUrl(&quot;jdbc:mysql://localhost:3309/sampledb&quot;);       </p><p>ds.setUsername(&quot;root&quot;);       </p><p>ds.setPassword(&quot;1234&quot;);       </p><p>Connection actualCon = ds.getConnection();   </p><p> </p><p>小结 </p><p>    不管采用何种持久化技术，都需要定义数据源。Spring附带了两个数据源的实现类包，你可以自行选择进行定义。在实际部署时，我们可能会直接采用应用服 务器本身提供的数据源，这时，则可以通过JndiObjectFactoryBean或jee命名空间引用JNDI中的数据源。 </p><p>DBCP与C3PO配置的区别：</p><p>C3PO ：</p><p>xml 代码</p><p>&lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot; destroy-method=&quot;close&quot;&gt;   </p><p>    &lt;property name=&quot;driverClass&quot;&gt;   </p><p>        &lt;value&gt;oracle.jdbc.driver.OracleDrivervalue&gt;   </p><p>    property&gt;   </p><p>    &lt;property name=&quot;jdbcUrl&quot;&gt;              </p><p>        &lt;value&gt;jdbc:oracle:thin:@10.10.10.6:1521:DataBaseNamevalue&gt;   </p><p>     property&gt;   </p><p>    &lt;property name=&quot;user&quot;&gt;   </p><p>        &lt;value&gt;testAdminvalue&gt;   </p><p>    property&gt;   </p><p>    &lt;property name=&quot;password&quot;&gt;   </p><p>        &lt;value&gt;123456value&gt;   </p><p>    property&gt;   </p><p>bean&gt;   </p><p> DBCP：</p><p>xml 代码</p><p>&lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot; destroy-method=&quot;close&quot;&gt;   </p><p>    &lt;property name=&quot;driverClassName&quot;&gt;   </p><p>        &lt;value&gt;oracle.jdbc.driver.OracleDrivervalue&gt;   </p><p>    property&gt;   </p><p>    &lt;property name=&quot;url&quot;&gt;              </p><p>        &lt;value&gt;jdbc:oracle:thin:@10.10.10.6:1521:DataBaseNamevalue&gt;   </p><p>     property&gt;   </p><p>    &lt;property name=&quot;username&quot;&gt;   </p><p>        &lt;value&gt;testAdminvalue&gt;   </p><p>    property&gt;   </p><p>    &lt;property name=&quot;password&quot;&gt;   </p><p>        &lt;value&gt;123456value&gt;   </p><p>    property&gt;   </p><p>bean&gt;   </p><p><br/></p><p><br/></p><p>快过年了，大家都在网上订票了，铁道部的订票网的访问速度，实在是太让人感动了。本人受到刺激后，对自己的框架做了一次性能优化，首先从数据库连接池开始。<br/>
    关于c3p0、dbcp和proxool，之类的比较，配置在网上有很多的文章，我这边就不浪费大家的时间了，主要讲下我用过这三个之后的体会。<br/></p><div>dbcp：框架以前使用的是dbcp，网上说，有很多BUG，至少，这些BUG，我是没有碰到过，从我们系统运行的情况来看，还可以，没什么太多问题，也许是我们的系统访问量不是太大（现在每日平台30个并发左右）。但有个非常坑爹场景，我们测试环境上，大大小小有8个项目在跑，数据库是跟一个ftp服务器搭建在一起（资源有限，没办法的事），ftp服务会经常重启，一重启，dbcp就无法自动连接了，那8个项目要重新启动一下才行。肯定有人会问，把那个数据库放到不经常重启的机器上，不就可以了吗？是的，这是一个办法，但还是不能回避dbcp无法自动重连的问题。</div><div>c3p0：框架目前使用的是c3p0，这个是在网上，也有很相关的文章，同时，也是hibernate推荐的，在这里不浪费大家的时间了。该连接池解决了dbcp无法自动重连问题，在稳定性方面，甚少我们的系统还不错。</div><div>proxool：关于这个连接池，网上说的例子也有很多，说是性能最好的一个连接池，坑爹的是，网上讲的它跟spring的整合，有很多都是不对的，直接通过spring配置就可以了，没有必要像网上说的，把listener，改成servlet，直接通过spring的bean配置就可以了，这个在网也有很多。关于这个连接池，我在测试时，发现默认情况下，是不会自动重连的，需要通过如下配置：                                &lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;<br/>
    &lt;property name=&quot;driverClassName&quot; value=&quot;org.logicalcobwebs.proxool.ProxoolDriver&quot; /&gt;<br/>
      &lt;property name=&quot;url&quot; value=&quot;xxxx.xml&quot; /&gt;<br/>
&lt;/bean&gt; 在xxxx.xml里配置                                                                     &lt;proxool&gt;<br/>
    &lt;alias&gt;pool&lt;/alias&gt;<br/>
    &lt;driver-url&gt;jdbc:mysql://192.168.1.4:3306/MIGRATE_TEST?characterEncoding=utf- 8&amp;autoReconnect=true&lt;/driver-url&gt;<br/>
    &lt;driver-class&gt;com.mysql.jdbc.Driver&lt;/driver-class&gt;<br/>
    &lt;driver-properties&gt;<br/>
        &lt;property name=&quot;user&quot; value=&quot;website&quot; /&gt;<br/>
        &lt;property name=&quot;password&quot; value=&quot;website&quot; /&gt;<br/>
        &lt;property name=&quot;autoReconnect&quot; value=&quot;true&quot; /&gt;<br/>
    &lt;/driver-properties&gt;<br/>
    &lt;minimum-connection-count&gt;1&lt;/minimum-connection-count&gt;<br/>
    &lt;maximum-connection-count&gt;8&lt;/maximum-connection-count&gt;<br/>
    &lt;prototype-count&gt;1&lt;/prototype-count&gt;<br/>
    &lt;test-before-use&gt;true&lt;/test-before-use&gt;<br/>
    &lt;house-keeping-sleep-time&gt;60000&lt;/house-keeping-sleep-time&gt;<br/>
&lt;/proxool&gt; mysql的URL的后面要加上autoReconnect=true，值得注意的是，当使用ibatis时，日志会报warn:registered a statement as closed which wasn't known to be open. 那是因为在ibatis</div><p>      package org.springframework.orm.ibatis;<br/>
      public class SqlMapClientTemplate extends JdbcAccessor implements SqlMapClientOperations {<br/>
         public &lt;T&gt; T execute(SqlMapClientCallback&lt;T&gt; action) throws DataAccessException {<br/>
         ..........<br/>
         finally {<br/>
            // Only close SqlMapSession if we know we've actually opened it<br/>
            // at the present level.<br/>
            if (ibatisCon == null) {<br/>
                session.close();// 由这段引起的，池ibatisCon不为空时，session永远不会关闭<br/>
            }<br/>
        }<br/>
         }<br/>
      }<br/>
      将红色部分改为 if (ibatisCon != null)，就行了<br/>
    4. 根据以上三种连接池的情况来看，在首次访问时，dbcp大约需要600毫秒，c3p0需要450毫秒，proxool需要1356毫秒，访问后，速度基本都在几十毫秒以内，除非sql写得很复杂。<br/>
以上的测试毫秒数，只是本人根据日志来反映的，不据参考价值，虽然网上说proxool性能最好，我觉得，还是自己使用后才知道真正的性能，所以我选择c3p0来试试，看看效果</p><p><br/></p><p><br/></p></div></div></span>
</div></body></html> 