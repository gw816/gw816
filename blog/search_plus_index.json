{"./":{"url":"./","title":"前言","keywords":"","body":"前言 JAVA程序员的成长历程 ——始于2019.05.06 Copyright © igavin.cc 2019 all right reserved该条目修订时间： 2019-05-30 13:47:14 "},"base/":{"url":"base/","title":"第一章 欢迎来到JAVA世界","keywords":"","body":"第一章 欢迎来到JAVA世界 Java编程语言是个简单、面向对象、分布式、解释性、健壮、安全与系统无关、可移植、高性能、多线程和动态的语言 本节引用维基百科。 Java是一种广泛使用的计算机编程语言，拥有跨平台、面向对象、泛型编程的特性，广泛应用于企业级Web应用开发和移动应用开发。 任职于太阳微系统（Sun Microsystems）的詹姆斯·高斯林等人于1990年代初开发Java语言的雏形，最初被命名为Oak，目标设置在家用电器等小型系统的编程语言，应用在电视机、电话、闹钟、烤面包机等家用电器的控制和通信。由于这些智能化家电的市场需求没有预期的高，Sun公司放弃了该项计划。随着1990年代互联网的发展，Sun公司看见Oak在互联网上应用的前景，于是改造了Oak，于1995年5月以Java的名称正式发布。Java伴随着互联网的迅猛发展而发展，逐渐成为重要的网络编程语言。 Java编程语言的风格十分接近C++语言。继承了C++语言面向对象技术的核心，舍弃了容易引起错误的指针，以引用取代；移除了C++中的运算符重载和多重继承特性，用接口取代；增加垃圾回收器功能。在Java SE 1.5版本中引入了泛型编程、类型安全的枚举、不定长参数和自动装/拆箱特性。太阳微系统对Java语言的解释是：“Java编程语言是个简单、面向对象、分布式、解释性、健壮、安全与系统无关、可移植、高性能、多线程和动态的语言” Java不同于一般的编译语言或解释型语言。它首先将源代码编译成字节码，再依赖各种不同平台上的虚拟机来解释执行字节码，从而具有“一次编写，到处运行”的跨平台特性。在早期JVM中，这在一定程度上降低了Java程序的运行效率。但在J2SE1.4.2发布后，Java的运行速度有了大幅提升。 与传统类型不同，Sun公司在推出Java时就将其作为开放的技术。全球的Java开发公司被要求所设计的Java软件必须相互兼容。“Java语言靠群体的力量而非公司的力量”是 Sun公司的口号之一，并获得了广大软件开发商的认同。这与微软公司所倡导的注重精英和封闭式的模式完全不同，此外，微软公司后来推出了与之竞争的.NET平台以及模仿Java的C#语言。后来Sun公司被甲骨文公司并购，Java也随之成为甲骨文公司的产品。 现时，移动操作系统Android大部分的代码采用Java 编程语言编程。 历史 早期的Java 语言最开始只是Sun计算机（Sun MicroSystems）公司在1990年12月开始研究的一个内部项目。Sun计算机公司的一个叫做帕特里克·诺顿的工程师被公司自己开发的C++和C语言编译器搞得焦头烂额，因为其中的API极其难用。帕特里克决定改用NeXT，同时他也获得了研究公司的一个叫做“Stealth计划”的项目的机会。 “Stealth计划”后来改名为“Green计划”，詹姆斯·高斯林和麦克·舍林丹也加入了帕特里克的工作小组。他们和其他几个工程师一起在加利福尼亚州门罗帕克市沙丘路的一个小工作室里面研究开发新技术，瞄准下一代智能家电（如微波炉）的程序设计，Sun公司预料未来科技将在家用电器领域大显身手。团队最初考虑使用C++语言，但是很多成员包括Sun的首席科学家比尔·乔伊，发现C++和可用的API在某些方面存在很大问题。 工作小组使用的是嵌入式系统，可以用的资源极其有限。很多成员发现C++太复杂以至很多开发者经常错误使用。他们发现C++缺少垃圾回收系统，还有可移植的安全性、分布程序设计、和多线程功能。最后，他们想要一种易于移植到各种设备上的平台。 根据可用的资金，乔伊决定开发一种集C语言和Mesa语言大成的新语言，在一份报告上，乔伊把它叫做“未来”，他提议Sun公司的工程师应该在C++的基础上，开发一种面向对象的环境。最初，高斯林试图修改和扩展C++的功能，他自己称这种新语言为C++ ++ --，但是后来他放弃了。他将要创造出一种全新的语言，被他命名为“Oak”（橡树），以他的办公室外的橡树命名。 就像很多开发新技术的秘密工程一样，工作小组没日没夜地工作到了1993年的夏天，他们能够演示新平台的一部分了，包括Green操作系统，Oak的程序设计语言，类库及其硬件。最初的尝试是面向一种类PDA设备，被命名为Star7，这种设备有鲜艳的图形界面和被称为“Duke”的智能代理来帮助用户。1992年12月3日，这台设备进行了展示。 同年11月，Green计划被转化成了“FirstPerson有限公司”，一个Sun公司的全资子公司，团队也被重新安排到了帕洛阿尔托。FirstPerson团队对建造一种高度交互的设备感兴趣，当时代华纳发布了一个关于电视机顶盒的征求提议书时（Request for proposal），FirstPerson改变了他们的目标，作为对征求意见书的响应，提出了一个机顶盒平台的提议。但是有线电视业界觉得FirstPerson的平台给予用户过多的控制权，因此FirstPerson的投标败给了SGI。与3DO公司的另外一笔关于机顶盒的交易也没有成功，由于他们的平台不能在电视工业产生任何效益，公司被并回Sun公司。 Java和互联网 1994年6月，在同约翰·盖吉、詹姆斯·高斯林、比尔·乔伊、帕特里克·诺顿、韦恩·罗斯因和埃里克·施密特经历了一场历时三天的头脑风暴后，团队决定再一次改变努力的目标，这次他们决定将该技术应用于万维网。他们认为随着Mosaic浏览器的到来，因特网正在向同样的高度互动的远景演变，而这一远景正是他们在有线电视网中看到的。作为原型，帕特里克·诺顿写了一个小型万维网浏览器，WebRunner，后来改名为HotJava[12]。 1994年10月，HotJava和Java平台为公司高层进行演示。1994年，Java 1.0a版本已经可以提供下载，但是Java和HotJava浏览器的第一次公开发布却是在1995年3月23日SunWorld大会上进行的。升阳公司的科学指导约翰·盖吉宣告Java技术。这个发布是与网景公司的执行副总裁马克·安德森的惊人发布一起进行的，宣布网景将在其浏览器中包含对Java的支持。1996年1月，Sun公司成立了Java业务集团，专门开发Java技术。 Java和“Java” 由于商标搜索显示Oak已被一家显卡制造商注册。于是同年，Oak被改名为Java。当使用十六进制编辑器打开由Java源代码编译出的二进制文件（.class文件）的话，最前面的32位将显示为CA FE BA BE，即词组“CAFE BABE”（咖啡屋宝贝）。 Java近况 在流行几年之后，Java在浏览器中的地位被逐步侵蚀。它在简单交互性动画方面的用途已经完全被Adobe公司的Flash排挤，2005年Java倾向只被用于雅虎游戏那样的更为复杂的应用程序。Java同时遭受到来自微软的反对，他们决定在新版本的Internet Explorer和Windows中不再附带Java平台。 与此相反，在万维网的服务器端和手持设备上，Java变得更加流行。很多网站在后端使用JSP和其他的Java技术。 在桌面系统上，独立的Java程序还是相对少见这是因为Java平台的运行开销较大，而许多人的计算机上没有安装Java，由于网络带宽在以前较小，下载Java曾经是个耗时的事情。但是随着计算机计算能力、网络带宽在10年中获取了很大的进步，同时虚拟机和编译器的质量得到了提高，许多应用程序得到了广泛的使用，包括： 开源软件： NetBeans和Eclipse等软件开发工具 Android操作系统 JEdit Azureus BitTorrent客户端。 JNode操作系统 Apache软件基金会的Ant、Derby、Hadoop、Jakarta、POI和Tomcat JBoss和GlassFish应用服务器 商业软件： EIOffice（永中Office） Minecraft 纯Java 3D游戏合金战士Chrome IBM Websphere、ColdFusion和WebLogic IntelliJ IDEA 还有许多用Java写的软件，可以在http://www.java.com 找到。在以下网页可以看到非常多用Java写的程序：http://java.sun.com/products/ 下面有大量用Java Swing开发的桌面Java程序 http://java.sun.com/products/jfc/tsc/sightings/ 当前Java提供以下三个版本： Java Platform, Enterprise Edition（Java EE：Java平台企业版） Java Platform, Standard Edition（Java SE：Java平台标准版） Java Platform, Micro Edition（Java ME：Java平台微型版） Java Platform, Card Edition Java开放源代码项目 2006年SUN在JavaOne公布Java 开放源代码项目，并推出OpenJDK项目[13]。Java虚拟机、Java编译器和Java类库以GNU通用公共许可证公开。 版本历史 主条目：Java版本历史 1995年5月23日，Java语言诞生 1996年1月，第一个JDK-JDK1.0诞生 1996年4月，10个最主要的操作系统供应商申明将在其产品中嵌入JAVA技术 1996年9月，约8.3万个网页应用了JAVA技术来制作 1997年2月18日，JDK1.1发布 1997年4月2日，JavaOne会议召开，参与者逾一万人，创当时全球同类会议规模之纪录 1997年9月，JavaDeveloperConnection社区成员超过十万 1998年2月，JDK1.1被下载超过2,000,000次 1998年12月8日，JAVA2企业平台J2EE发布 1999年6月，SUN公司发布Java的三个版本：标准版（J2SE）、企业版（J2EE）和微型版（J2ME） 2000年5月8日，JDK1.3发布 2000年5月29日，JDK1.4发布 2001年6月5日，NOKIA宣布，到2003年将出售1亿部支持Java的手机 2001年9月24日，J2EE1.3发布 2002年2月26日，J2SE1.4发布，自此Java的计算能力有了大幅提升 2004年9月30日18:00PM，J2SE1.5发布，成为Java语言发展史上的又一里程碑。为了表示该版本的重要性，J2SE1.5更名为Java SE 5.0 2005年6月，JavaOne大会召开，SUN公司公开Java SE 6。此时，Java的各种版本已经更名，以取消其中的数字“2”：J2EE更名为Java EE，J2SE更名为Java SE，J2ME更名为Java ME 2006年12月，SUN公司发布JRE6.0 2009年12月，SUN公司发布Java EE 6 2010年11月，由于Oracle公司对于Java社群的不友善，因此Apache扬言将退出JCP[14] 2011年7月28日，Oracle公司发布Java SE 7 2014年3月18日，Oracle公司发表Java SE 8 2017年9月21日，Oracle公司发表Java SE 9 2018年3月21日，Oracle公司发表Java SE 10 2018年9月25日，Java SE 11发布 语言特性 Java之所以被开发，是要达到以下五个目的： 应当使用面向对象程序设计方法学 应当允许同一程序在不同的计算机平台执行 应当包括内建的对计算机网络的支持 应当被设计成安全地执行远端代码 应当易于使用，并借鉴以前那些面向对象语言（如C++）的长处。 Java技术主要分成几个部分：Java语言、Java运行环境、类库。一般情况下说Java时并不区分指的是哪个部分。 Java在1.5版本时，做了重大改变，Sun公司并1.5版本重命名为Java 5.0。 面向对象 Java的特点之一就是面向对象，是程序设计方法的一种。“面向对象程序设计语言”的核心之一就是开发者在设计软件的时候可以使用自定义的类型和关联操作。代码和数据的实际集合体叫做“对象”。一个对象可以想象成绑定了很多“行为（代码）”和“状态（数据）”的物体。对于数据结构的改变需要和代码进行通信然后操作，反之亦然。面向对象设计让大型软件工程的计划和设计变得更容易管理，能增强工程的健康度，减少失败工程的数量。 跨平台性 跨平台性是java主要的特性之一，跨平台使得使用用Java语言编写的程序可以在编译后不用经过任何更改，就能在任何硬件设备条件下运行。这个特性经常被称为“一次编译，到处运行”。 执行Java应用程序必须安装Java 运行时环境（Java Runtime Environment，JRE），JRE包括Java虚拟机（Java Virtual Machine，JVM），以及Java平台核心类和基础Java 平台库。[15]通过JVM才能在计算机系统执行Java应用程序（Java Application），这与.Net Framework的情况一样，所以计算机上没有安装JVM，那么这些java程序将不能够执行。 实现跨平台性的方法是大多数编译器在进行Java语言程序的编码时候会生成一个用字节码写成的“半成品”，这个“半成品”会在Java虚拟机（解释层）的帮助下运行，虚拟机会把它转换成当前所处硬件平台的原始代码。之后，Java虚拟机会打开标准库，进行数据（图片、线程和网络）的访问工作。主要注意的是，尽管已经存在一个进行代码翻译的解释层，有些时候Java的字节码代码还是会被JIT编译器进行二次编译。 有些编译器，比如GCJ，可以自动生成原始代码而不需要解释层。但是这些编译器所生成的代码只能应用于特定平台。并且GCJ当前只支持部分的Java API。 甲骨文公司对于Java的许可是“全兼容的”，这也导致了微软和升阳关于微软的程序不支持RMI和JNI接口、并且增加特性为己所用的法律争端。升阳最终赢得了官司，获得了大约两千万美元的赔偿，法院强制要求微软执行升阳公司关于Java的许可要求。作为回应，微软不再在Windows系统中捆绑Java，最新的Windows版本，Windows Vista和Internet Explorer 7.0版本也不再提供对于Java应用程序和控件的支持。但是升阳公司和其他使用Java运行时系统的公司在Windows操作系统下对用户提供无偿的第三方插件和程序支持。 Java语言使用解释层最初是为了轻巧性。所以这些程序的运行效率比C语言和C++要低很多，用户也对此颇有微词。很多最近的调查显示Java的程序运行速度比几年前要高出许多，有些同样功能的程序的效率甚至超过了C++和C语言编写的程序。 Java语言在最开始应用的时候是没有解释层的，所有需要编译的代码都直接转换成机器的原始代码。这样做虽然使程序获得了最佳的性能，但是导致程序异常臃肿。从JIT技术开始，Java的程序都经过一次转换之后才变成机器码。很多老牌的第三方虚拟机都使用一种叫做“动态编译”的技术，也就是说虚拟机实时监测和分析程序的运行行为，同时选择性地对程序所需要的部分进行编译和优化。所有这些技术都改善了代码的运行速度，但是又不会让程序的体积变得失常。 程序的轻便性事实上是软件编写很难达到的一个目标，Java虽然成功地实现了“一次编译，到处运行”，但是由于平台和平台之间的差异，所编写的程序在转换代码的时候难免会出现微小的、不可察觉的错误和意外。有些程序员对此非常头疼，他们嘲笑Java的程序不是“一次编译，到处运行”，而是“一次编译，到处调试”。以Java AWT为例，早期Java AWT内提供的按钮、文字区等均是以计算机系统所默认的样式而显示。这令Java程序在有些没有提供图案的计算机系统产生错误（在Microsoft Windows设有窗口管理器，在一些Linux distribution则没有）。后来SUN公司针对Java AWT一些问题而推出Java Swing。 平台无关性让Java在服务器端软件领域非常成功。很多服务器端软件都使用Java或相关技术建立。 自动垃圾回收（Garbage Collection） C++语言被用户诟病的原因之一是大多数C++编译器不支持垃圾收集机制。通常使用C++编程的时候，程序员于程序中初始化对象时，会在主机存储器堆栈上分配一块存储器与地址，当不需要此对象时，进行析构或者删除的时候再释放分配的存储器地址。如果对象是在堆栈上分配的，而程序员又忘记进行删除，那么就会造成存储器泄漏（Memory Leak）。长此以往，程序运行的时候可能会生成很多不清除的垃圾，浪费了不必要的存储器空间。而且如果同一存储器地址被删除两次的话，程序会变得不稳定，甚至崩溃。因此有经验的C++程序员都会在删除之后将指针重置为NULL，然后在删除之前先判断指针是否为NULL。 C++中也可以使用“智能指针”（Smart Pointer）或者使用C++托管扩展编译器的方法来实现自动化存储器释放，智能指针可以在标准类库中找到，而C++托管扩展被微软的Visual C++ 7.0及以上版本所支持。智能指针的优点是不需引入缓慢的垃圾收集机制，而且可以不考虑线程安全的问题，但是缺点是如果不善使用智能指针的话，性能有可能不如垃圾收集机制，而且不断地分配和释放存储器可能造成存储器碎片，需要手动对堆进行压缩。除此之外，由于智能指针是一个基于模板的功能，所以没有经验的程序员在需要使用多态特性进行自动清理时也可能束手无策。 Java语言则不同，上述的情况被自动垃圾收集功能自动处理。对象的创建和放置都是在存储器堆栈上面进行的。当一个对象没有任何引用的时候，Java的自动垃圾收集机制就发挥作用，自动删除这个对象所占用的空间，释放存储器以避免存储器泄漏。 注意程序员不需要修改finalize方法，自动垃圾收集也会发生作用。但是存储器泄漏并不是就此避免了，当程序员疏忽大意地忘记解除一个对象不应该有的引用时，存储器泄漏仍然不可避免。 不同厂商、不同版本的JVM中的存储器垃圾回收机制并不完全一样，通常越新版本的存储器回收机制越快，IBM、BEA、SUN等等开发JVM的公司都曾宣称过自己制造出了世界上最快的JVM，JVM性能的世界纪录也在不断的被打破并提高。 IBM有一篇有关Java存储器回收机制比不激活垃圾收集机制的C++存储器处理快数倍的技术文章[16]，而著名的Java技术书籍《Java编程思想》（Thinking in Java）也有一段论述Java存储器及性能达到甚至超过C++的章节[17]。 基本语法 编写Java程序前应注意以下几点： 大小写敏感：Java是大小写敏感的，这就意味着标识符Hello与hello是不同的。 类名：对于所有的类来说，类名的首字母应该大写。如果类名由若干单词组成，那么每个单词的首字母应该大写，例如MyFirstJavaClass。 方法名：所有的方法名都应该以小写字母开头。如果方法名含有若干单词，则后面的每个单词首字母大写，例如myFirstJavaMethod。 源文件名：源文件名必须和类名相同。当保存文件的时候，你应该使用类名作为文件名保存（切记Java是大小写敏感的），文件名的后缀为.java。（如果文件名和类名不相同则会导致编译错误）。 主方法入口：所有的Java程序由public static void main（String[] args）方法开始执行。 Java关键字 下面列出了Java关键字。这些关键字不能用于常量、变量、和任何标识符的名称。 类别 关键字 说明 访问控制 private 私有的 protected 受保护的 public 公共的 类、方法和变量修饰符 abstract 声明抽象 class 类 extends 扩允,继承 final 最终值,不可改变的 implements 实现（接口） interface 接口 native 本地，原生方法（非Java实现） new 新,创建 static 静态 strictfp 严格,精准 synchronized 线程,同步 transient 短暂 volatile 易失 程序控制语句 break 跳出循环 case 定义一个值以供switch选择 continue 继续 default 默认 do 运行 else 否则 for 循环 if 如果 instanceof 实例 return 返回 switch 根据值选择执行 while 循环 错误处理 assert 断言表达式是否为真 catch 捕捉异常 finally 有没有异常都执行 throw 抛出一个异常对象 throws 声明一个异常可能被抛出 try 捕获异常 包相关 import 引入 package 包 基本类型 boolean 布尔型 byte 字节型 char 字符型 double 双精度浮点 float 单精度浮点 int 整型 long 长整型 short 短整型 null 空 变量引用 super 父类,超类 this 本类 void 无返回值 保留关键字 goto 是关键字，但不能使用 const 是关键字，但不能使用 注释 注释的作用：标识程序是干什么的，以及它是如何构建的。注释帮助程序员进行相互沟通以及理解程序。注释不是程序设计语言，所以编译器编译程序时忽略它们。 接口和类别 Java自带了创建接口的类别，可以这样使用： public interface Deleteable { void delete(); System.out.println(\" ATTACH DATABASE 'DatabaseName' As 'Alias-Name'\"); } 这段代码的意思是任何实现（implement）Deleteable接口的类别都必须实现delete()方法。每个类别对这个方法的实现可以自行定制。由此概念可以引出很多种使用方法，下面是一个类别的例子： public class Fred implements Deleteable { // 必須實作Deleteable介面中的delete方法 @Override public void delete() { // 實作的程式碼 } // 這個類別也可以包含其他方法 public void doOtherStuff() { } } 在另外一个类别中，可以使用这样的代码： public void deleteAll（Deleteable [] list）{ for（int i = 0; i 因为队列中所有的对象都可以使用delete()方法。Deleteable队列中包含Fred对象的引用，而这个类别和其他Deleteable类别在使用deleteAll()方法时候不需要进行任何改变。 之所以这样做就是为了在接口的执行和其代码之间进行区别。举例来说，一个名叫Collection的接口可以包含任何对象所需要的引入、转换和存储数据的方法，其他的类都可以使用这个接口。但是这个接口可以是一个可重定义大小的队列、一个链表或者是其他功能的集合。 这种特性其实是一种折中的办法。Java的设计者们不想让Java有多重继承的特性，因为C++的多重继承显示了这种特性的困难。Java的接口功能可以提供同样的功能，但是又不会很复杂。 应用程序开发接口 在Java语言中，应用程序接口（API）化身成类，并且分组成为包。每个包中包含有相关的接口和类。对于不同的平台，Java提供了不同版本的包。API的设定由sun公司和其他公司通过JCP（Java社群程序）决定。任何公司和个人都可以参与这个工程，对API进行设计。2004年，IBM和BEA公司准备联合对官方的Java开源软件工程进行支持，但是2005年初，sun公司拒绝了这个支持。 Hello World 下面这个程序显示“Hello, world!”然后结束运行，注意java.lang包是自动加载的，所以不需要在程序之前加入import java.lang.*; public class HelloWorld { public static void main(String[] args) { System.out.println(\"Hello World!\"); // Prints the string to the console. } } 关于Java的批评 Java试图通过新的方式解决软件编写的复杂性。很多人认为Java语言做到了它承诺的一切。但是Java并不是一门完美的语言。 整体性问题 并不是所有的工程和环境需要企业等级的复杂性，比如一个简单的个人网站或者独自编程的程序师所写的程序。这些程序师会发现Java的复杂管理对于自己要做的程序来说过于强大了。一些人觉得Java在面向对象上面做的没有Ruby和Smalltalk纯粹。但是最新出现的用Java实现的语言Groovy解决了这些问题。 作为一种已经创建的新技术，Java显然综合了很多语言的特性，比如C++、C语言、Python等等。一些对于Java的评论认为Java的不变性在动摇。 语言问题 有些程序师不喜欢原始类型（primitive type）和类别（class）的分离，尤其是那些曾经使用过Smalltalk和Ruby的程序员。Java的代码相对于其他的代码来说过于冗长，这与它的轻便化声明相违背。 Java是一种单继承的语言。这也导致了程序师在试图使用多重继承时候的不便，而很多语言都可以使用这个特性。但是Java可以使用接口类，把多重继承可能导致的风险减少到最小。Java不支持运算符重载，这是为了防止运算符重载使得代码的功能变得不清晰。但是用Java实现的语言Groovy可以进行运算符重载。过去Java对于文本的操作和其他语言，比如Perl和PHP相比差的较多，但Java在1.4版本时候引入了正则表达式。 至Java 1.7为止，Java语言不支持闭包（closure）和混入（mixin）特性。 Java 1.8加入闭包（Lambda Expressions）[2] 。 类库问题 使用Swing平台编写的带有GUI（图形用户界面）的程序和其他原始程序非常不同。选用AWT工具包编写程序的程序师看到的都是原始接口，而且也无法获得先进的GUI编程支持，如果使用的话，就要提供每个平台上面所需的API，这将是一项庞大的工程。Swing则是完全用Java语言所写的程序，避免了接口元素重复的问题，只使用所有平台都支持的最基本的绘图机制。但是很多用户不知道如何在Java风格和Windows风格之间进行转换，结果造成了Java程序的接口在很多程序中非常特殊。苹果计算机已经提供了优化过的Java运行时程序，包含了Mac OS X的经典Aqua接口风格。 在IBM捐赠给Eclipse基金会的SWT界面框架中，用户会看到熟悉的本地风格界面。但这又引起了不同喜好的开发人员之间的争论。 性能问题 由于Java编译器和虚拟机的不同对Java代码的性能影响比语言本身的影响大的多，所以统一讨论Java的程序的性能经常是有误导性的。据IBM的数据，在同样的硬件上2001年时的IBMJDK版本的性能是1996年的JDK版本的十倍左右。[18]而即使是在同一时期，不同公司的JDK和JRE的性能也不一样，比如SUN、IBM、BEA等公司都有自己开发的JDK和JRE。 Java语言的一些特性不可避免的有额外的性能代价，例如数组范围检查、运行时类型检查等等。Java程序的性能还会因为不同的动态复杂性和垃圾处理机制使用的多少而各有不同。如果JVM的实现比较优化的话，那么这些功能甚至可以增加存储器分配的性能。这和总是使用STL或者托管C++的程序的情况类似。 尽管如此，仍然有许多人认为Java的性能低。这部分归因于Sun公司最初的JVM实现使用未优化的解释机制来运行字节码。一些新版本的JVM使用Just-In-Time（JIT）编译器，在加载字节码的时候将其编译成针对运行环境的本地代码来实现一些本地编译器的优化特性。Just-In-Time机制和本地编译的性能比较仍旧是一个有争议的话题。JIT编译需要很多时间，对于运行时间不长或者代码很多的大型程序并不适宜。但是不算JIT编译阶段的话，程序的运行性能在很多JVM下可以和本地编译的程序一争短长，甚至在一些计算比较密集的数值计算领域也是这样。当前，Java已经使用更先进的HotSpot技术来代替JIT技术，Java的性能有了更进一步的提升。另外，在使用-server选项运行Java程序时，也可以对Java进行更深入的优化，比如在运行时将调用较多的方法内联（inline）到程序中来提高运行速度，这就是所谓的“动态优化”，而本地编译器是无法做到这一点的；这也是一些Java代码比对应用C/C++等语言编写的本地代码运行的更快的原因之一。微软的.NET平台也使用JIT编译器，所以也有类似问题。 Java的设计目的主要是安全性和可携性，所以对于一些特性，比如对硬件架构和存储器地址访问的直接访问都被去除了。如果需要间接调用这些底层功能的话，就需要使用JNI（Java本地接口）来调用本地代码，而间接访问意味着频繁调用这些特性时性能损失会很大，微软的.NET平台也有这样的问题。所以到当前为止，性能敏感的代码，例如驱动程序和3D电子游戏，还是大多使用本地编译，甚至直接以不直接支持面向对象的C语言或机器代码编写。但最近已经有了许多用纯Java编写的3D游戏，其效果与用C语言编写的不相上下，例如“合金战士”（英文名：Chrome）。这主要是因为新版的Java 3D技术已经能像C++一样调用硬件加速，也就是使用显卡来加速，无论是C++还是Java语言写的3D游戏都是使用显卡及GPU来处理，从而使得CPU可以专注于其他方面的工作。 用途 1.桌面GUI应用程序： Java通过抽象窗口工具包（AWT），Swing和JavaFX等多种方式提供GUI开发。虽然AWT包含许多预先构建的组件，如菜单，按钮，列表以及众多第三方组件，但Swing（一个GUI小部件工具包）还提供某些高级组件，如树，表格，滚动窗格，选项卡式面板和列表。JavaFX是一组图形和媒体包，提供了Swing互操作性，3D图形功能和自包含的部署模型，可以快速编写Java小应用程序和应用程序的脚本。[19] 2.移动应用程序： Java Platform，Micro Edition（Java ME或J2ME）是一个跨平台框架，用于构建可在所有Java支持的设备（包括功能手机和智能手机）上运行的应用程序。此外，最受欢迎的移动操作系统之一的Android应用程序通常使用Android软件开发工具包（SDK）或其他环境在Java中编写脚本。 3.嵌入式系统： 从微型芯片到专用计算机的嵌入式系统是执行专门任务的大型机电系统的组件。诸如SIM卡，蓝光光盘播放器，公用事业仪表和电视机等多种设备都使用嵌入式Java技术。据甲骨文公司称，100％的蓝光光盘播放器和1.25亿台电视设备都采用Java技术。 Web应用程序： Java通过Servlets，Struts或JSP提供对Web应用程序的支持。编程语言提供的简单编程和更高的安全性使得大量政府应用程序可用于基于Java的健康，社会安全，教育和保险。Java也可以使用Broadleaf等开源电子商务平台开发电子商务Web应用程序。 Web服务器和应用程序服务器： 今天的Java生态系统包含多个Java Web服务器和应用程序服务器。虽然Apache Tomcat，Simple，Jo !, Rimfaxe Web服务器（RWS）和Project Jigsaw占据了Web服务器空间，但WebLogic，WebSphere和Jboss EAP在商业应用服务器领域占据重要地位[20]。 6.企业应用程序： Java企业版（Java EE）是一种流行的平台，为脚本和运行企业软件（包括网络应用程序和Web服务）提供API和运行时环境。甲骨文宣称Java在97％的企业计算机上运行。Java中更高的性能保证和更快的计算能力导致像Murex这样的高频交易系统被编入脚本中。它也是各种银行应用程序的中枢，它们将Java从前端用户端运行到后端服务器端。 7.科学应用： Java是许多软件开发人员用于编写涉及科学计算和数学运算的应用程序的选择。这些程序通常被认为是快速和安全的，具有更高的便携性和低维护性。像MATLAB这样的应用程序使用Java来交互用户界面和作为核心系统的一部分。 参见 比较Java和C++ 比较C Sharp和Java Java元数据接口 Java applet Java平台 Java RMI 注释 ^ Java 5.0 增加了多种新特性（包括foreach循环，自动装箱、拆箱，可变参数函数以及annotations）, after they were introduced in the similar (and competing) C# language.[2][3] ^ Niklaus Wirth stated on a number of public occasions, e.g. in a lecture at the Polytechnic Museum, Moscow in September, 2005 (several independent first-hand accounts in Russian exist, e.g. one with an audio recording: Filippova, Elena. Niklaus Wirth's lecture at the Polytechnic Museum in Moscow. 2005-09-22.), that the Sun Java design team licensed the Oberon compiler sources a number of years prior to the release of Java and examined it: a（relative）compactness, type safety, garbage collection, no multiple inheritance for classes – all these key overall design features are shared by Java and Oberon. ^ Patrick Naughton cites Objective-C as a strong influence on the design of the Java programming language, stating that notable direct derivatives include Java interfaces（derived from Objective-C's protocol）and primitive wrapper classes.[7] ^ In the summer of 1996, Sun was designing the precursor to what is now the event model of the AWT and the JavaBeans TM component architecture. Borland contributed greatly to this process. We looked very carefully at Delphi Object Pascal and built a working prototype of bound method references in order to understand their interaction with the Java programming language and its APIs.[10] Copyright © igavin.cc 2019 all right reserved该条目修订时间： 2019-05-08 09:07:17 "},"base/base.html":{"url":"base/base.html","title":"第1节：基础","keywords":"","body":"第1节：基础 千里之行，始于足下。从本章开始讲解JAVA基础部分——JavaSE。 JavaSE大概包含以下内容： 四大特征（抽象、封装、继承和多态）、数据类型、自动装箱、基础语法、异常、范型、集合、流与文件、反射、枚举、注解。 涉及到的知识点大概有： 开发环境Java SDK 下载和安装 jvm 虚拟机运行原理 编程基础 标识符命名规范 Java数据类型 运算符 分支语句（if,switch） 循环语句(for,while) 函数的定义方法 面向对象基础 面向对象与面向过程语言之间的区别 面向对象基本思想（封装） 类的定义方法 对象和类的关系 对象的创建方法 通过对象使用成员变量和成员函数的方法 构造函数的作用 函数的重载 static 的作用 this的作用 面向对象高级面向对象基本思想（继承） 继承的作用 继承的语法特点 super的使用方法 面向对象基本思想（多态） 对象的向上转型和向下转型 final关键字的作用 抽象类和接口的定义方法 接口和抽象类的语法特征 抽象类和接口在面向对象编程当中的地位和意义 设计模式（工厂方法模式） Java当中异常的定义 异常的分类以及各自的特点 try…catch…finally 结构的处理方法 throw和throws 的使用方法 自定义异常的使用方法 内部类的定义方法 匿名内部类的定义方法 内部类的常见使用方法 线程 线程的基本定义 在 Java 当中实现线程的两种方法(使用Thread 或Runnable) 线程运行状态介绍（准备，运行，阻塞，死亡） 线程间通信的方法 线程同步 线程死锁 IO 基本概念 输入流和输出流的作用 Java当中IO 流的分类方法 常 见 IO 类的使用方法（File,FileInput,FileOutput,Reader,Writer以及其子类的使用方法） 类库 类 集框架中常见类的使用方法（ArrayList,LinkedList,Queue,Stack,HashSet,HashMap） 日期相关类的使用方法（Data，DataFormat，Calander） 数据库关系型数据库的基本概念 SQL 分类 DDL，DML，查询 ……还有更多 Copyright © igavin.cc 2019 all right reserved该条目修订时间： 2019-05-08 09:01:46 "},"base/helloworld.html":{"url":"base/helloworld.html","title":"第2节：上手","keywords":"","body":"第2节：上手 一.开发环境Java SDK 下载和安装 1.下载 官网地址：http://www.oracle.com/technetwork/java/javase/downloads/index.html 选择适合自己电脑系统的版本下载。本机是MAC，jdk8。 2.安装 安装过程略。最后在控制台进入安装目录的bin下，执行 java -version 输出：java version \"1.8.0_201\" Java(TM) SE Runtime Environment (build 1.8.0_201-b09) Java HotSpot(TM) 64-Bit Server VM (build 25.201-b09, mixed mode) 见到以上结果就代表安装成功，但是每次进入该目录才能执行命令很麻烦，我们可以把java加入到系统环境变量，这样无论在哪个目录都可以直接执行。 配置环境变量过程略。 二.jvm 虚拟机运行原理 Copyright © igavin.cc 2019 all right reserved该条目修订时间： 2019-05-08 11:31:04 "},"linux/":{"url":"linux/","title":"第二章 Linux","keywords":"","body":"第二章 Linux 总结了一些Linux常用功能 MAC通用 Copyright © igavin.cc 2019 all right reserved该条目修订时间： 2019-05-22 12:50:48 "},"linux/shell.html":{"url":"linux/shell.html","title":"第1节：Linux如何查看进程、杀死进程、启动进程等常用命令","keywords":"","body":"第1节：Linux如何查看进程、杀死进程、启动进程等常用命令 1.查进程 ps命令查找与进程相关的PID号： ps a 显示现行终端机下的所有程序，包括其他用户的程序。 ps -A 显示所有程序。 ps c 列出程序时，显示每个程序真正的指令名称，而不包含路径，参数或常驻服务的标示。 ps -e 此参数的效果和指定\"A\"参数相同。 ps e 列出程序时，显示每个程序所使用的环境变量。 ps f 用ASCII字符显示树状结构，表达程序间的相互关系。 ps -H 显示树状结构，表示程序间的相互关系。 ps -N 显示所有的程序，除了执行ps指令终端机下的程序之外。 ps s 采用程序信号的格式显示程序状况。 ps S 列出程序时，包括已中断的子程序资料。 ps -t 指定终端机编号，并列出属于该终端机的程序的状况。 ps u 以用户为主的格式来显示程序状况。 ps x 显示所有程序，不以终端机来区分。 最常用的方法是ps aux,然后再通过管道使用grep命令过滤查找特定的进程,然后再对特定的进程进行操作。 ps aux | grep program_filter_word,ps -ef |grep tomcat ps -ef|grep java|grep -v grep 显示出所有的java进程，去处掉当前的grep进程。 2.杀进程 使用kill命令结束进程：kill xxx 常用：kill －9 324 Linux下还提供了一个killall命令，可以直接使用进程的名字而不是进程标识号，例如：# killall -9 NAME 3.进入到进程的执行文件所在的路径下，执行文件 ./文件名 附： 这是本人花了两天时间整理得来的，一些最常用的地球人都知道的命令就省去啦！最后提供pdf手册下载 更改档案拥有者 命令 : chown [-cfhvR] [--help] [--version] user[:group] file... 功能 : 更改文件或者文件夹的拥有者 参数格式 : 　　 user : 新的档案拥有者的使用者 IDgroup : 新的档案拥有者的使用者群体(group) 　　 -c : 若该档案拥有者确实已经更改，才显示其更改动作 　　 -f : 若该档案拥有者无法被更改也不要显示错误讯息 　　 -h : 只对于连结(link)进行变更，而非该 link 真正指向的档案 　　 -v : 显示拥有者变更的详细资料 　 　-R : 对目前目录下的所有档案与子目录进行相同的拥有者变更(即以递回的方式逐个变更) 例如：chown -R oracle:oinstall /oracle/u01/app/oracle 更改目录拥有者为oracle 修改权限 命令：chmod (change mode) 功能：改变文件的读写和执行权限。有符号法和八进制数字法。 选项：(1)符号法： 命令格式：chmod {u|g|o|a}{+|-|=}{r|w|x} filename u (user) 表示用户本人。 g (group) 表示同组用户。 o (oher) 表示其他用户。 a (all) 表示所有用户。 + 用于给予指定用户的许可权限。 - 用于取消指定用户的许可权限。 = 将所许可的权限赋给文件。 r (read) 读许可，表示可以拷贝该文件或目录的内容。 w (write) 写许可，表示可以修改该文件或目录的内容。 x (execute)执行许可，表示可以执行该文件或进入目录。 (2)八进制数字法： 命令格式：chmod abc file 其中a,b,c各为一个八进制数字，分别表示User、Group、及Other的权限。 4 (100) 表示可读。 2 (010) 表示可写。 1 (001) 表示可执行。 若要rwx属性则4+2+1=7； 若要rw-属性则4+2=6； 若要r-x属性则4+1=5。 例如：# chmod a+rx filename 让所有用户可以读和执行文件filename。 # chmod go-rx filename 取消同组和其他用户的读和执行文件filename的权限。 # chmod 741 filename 让本人可读写执行、同组用户可读、其他用户可执行文件filename。 chmod -R 755 /home/oracle 递归更改目录权限，本人可读写执行、同组用户可读可执行、其他用户可读可执行 修改文件日期 命令：touch 格式：touch filenae 功能：改变文件的日期，不对文件的内容做改动，若文件不存在则建立新文件。 例如：% touch file 链接文件 命令：ln (link) 格式：ln [option] filename linkname ln [option] directory pathname 功能：为文件或目录建立一个链。其中，filename和directory是源文件名和 源目录名；linkname和pathname分别表示与源文件或源目录名相链接的 文件或目录。 选项：-s 为文件或目录建立符号链接。不加-s表示为文件或目录建立硬链接 注释：链接的目地在于，对一个文件或目录赋予两个以上的名字，使其可以出 现在不同的目录中，既可以使文件或目录共享，又可以节省磁盘空间。 例如：% ln -s filename linkname 显示日期 命令：date 例如：% date 显示日历 命令：cal (calendar) 格式：cal [month] year 功能：显示某年内指定的日历 例如：% cal 1998 显示文件头部 命令：head 格式：head [option] filename 功能：显示文件的头部 选项：缺省 显示文件的头10行。 -i 显示文件的开始 i行。 例如：% head filename 显示文件尾部 命令：tail 格式：tail [option] filename 功能：显示文件的尾部 选项：缺省 显示文件的末10行。 -i 显示文件最后 i行。 +i 从文件的第i行开始显示。 例如：% tail filename 显示用户标识 命令：id 格式：id [option] [user] 功能：显示用户标识及用户所属的所有组。 选项：-a 显示用户名、用户标识及用户所属的所有组 注释： 例如：% id username 查看当前登录的用户 命令：users 显示都谁登录到机器上 命令：who 格式：who 功能：显示当前正在系统中的所有用户名字，使用终端设备号，注册时间。 例如：% who 显示当前终端上的用户名 命令：whoami 格式：whoami 功能：显示出当前终端上使用的用户。 例如：% whoami 寻找文件 命令：find 格式：find pathname [option] expression 功能：在所给的路经名下寻找符合表达式相匹配的文件。 选项：-name 表示文件名 -user 用户名，选取该用户所属的文件 -size 按大小查找，以block为单位，一个block是512B -mtime n 按最后一次修改时间查找，选取n天内被修改的文件 -perm 按权限查找 -type 按文件类型查找 -atime 按最后一次访问时间查找 例如：% find ./ -name 'abc' -print 搜索文件中匹配符 命令：grep 格式：grep [option] pattern filenames 功能：逐行搜索所指定的文件或标准输入，并显示匹配模式的每一行。 选项：-i 匹配时忽略大小写 -v 找出模式失配的行 例如：% grep -i 'java*' ./test/run.sh 统计文件字数 命令：wc [option] filename 功能：统计文件中的文件行数、字数和字符数。 选项：-l 统计文件的行数 -w 统计文件的单词数 -c 统计文件的字符数 注释：若缺省文件名则指标准输入 例如：% wc -c ./test/run.sh 显示磁盘空间 命令：df (disk free) 格式：df [option] 功能：显示磁盘空间的使用情况，包括文件系统安装的目录名、块设备名、总 字节数、已用字节数、剩余字节数占用百分比。 选项： -a：显示全部的档案系统和各分割区的磁盘使用情形 -i：显示i -nodes的使用量 -k：大小用k来表示 (默认值) -t：显示某一个档案系统的所有分割区磁盘使用量 -x：显示不是某一个档案系统的所有分割区磁盘使用量 -T：显示每个分割区所属的档案系统名称 -h: 表示使用「Human-readable」的输出，也就是在档案系统大小使用 GB、MB 等易读的格式。 注释： 例如：% df -hi 查询档案或目录的磁盘使用空间 命令：du (disk usage) 格式：du [option] [filename] 功能：以指定的目录下的子目录为单位，显示每个目录内所有档案所占用的磁盘空间大小 选项： -a：显示全部目录和其次目录下的每个档案所占的磁盘空间 -b：大小用bytes来表示 (默认值为k bytes) -c：最后再加上总计 (默认值) -s：只显示各档案大小的总合 -x：只计算同属同一个档案系统的档案 -L：计算所有的档案大小 -h: 表示档案系统大小使用 GB、MB 等易读的格式。 例如：% du -a % du -sh /etc 只显示该目录的总合 % du /etc | sort -nr | more 统计结果用sort 指令进行排序， sort 的参数 -nr 表示要以数字排序法进行反向排序。 显示进程 命令：ps 格式：ps [option] 功能：显示系统中进程的信息。包括进程ID、控制进程终端、执行时间和命令。 选项： -a 显示所有进程信息 -U uidlist 列出这个用户的所有进程 -e 显示当前运行的每一个进程信息 -f 显示一个完整的列表 -x 显示包括没有终端控制的进程状况 。 注释： 例如：% ps -ef % ps -aux 然后再利用一个管道符号导向到grep去查找特定的进程,然后再对特定的进程进行操作。 终止进程 命令：kill 格式：kill [option] pid 功能：向指定的进程送信号或终止进程。kill指令的用途是送一个signal给某一个process， 因为大部份送的都是用来杀掉 process 的 SIGKILL 或 SIGHUP ，因此称为 kill选项：-9 强行终止进程 注释：pid标示进程号，可由ps命令得到。 例如：% kill -9 pid 你也可以用 kill -l 来察看可代替 signal 号码的数目字。kill 的详细情形请参阅 man kill。 查看自己的IP地址 命令：ifconfig 格式：ifconfig -a 查看路由表 命令：netstat 格式：netstat -rn 远程登录 命令：telnet 格式：telnet hostname 文件传输 命令：ftp (file transfer program) 格式：ftp hostname 功能：网络文件传输及远程操作。 选项：ftp命令： cd [dirname] 进入远程机的目录 lcd [dirname] 设置本地机的目录 dir/ls 显示远程的目录文件 bin 以二进制方式进行传输 asc 以文本文件方式进行传输 get/mget 从远程机取一个或多个文件 put/mput 向远程机送一个或多个文件 prompt 打开或关闭多个文件传送时的交互提示 close 关闭与远程机的连接 quit 退出ftp !/exit ftp登陆状态下，!表示暂时退出ftp状态回到本地目录，exit表示返回ftp状态 注释： 例如：% ftp hostname 查看自己的电子邮件 命令：mailx 格式：mailx 选项： delete 删除 next 下一个 quit 退出 reply 回复 回忆命令 命令：history 格式：history 功能：帮助用户回忆执行过的命令。 选项： 注释： 例如：% history 网上对话 命令：talk 格式：talk username 功能：在网上与另一用户进行对话。 选项： 注释：对话时系统把终端分为上下两部分，上半部显示自己键入信息，下半部 显示对方用户键入的信息。键入delete或Ctrl+C则结束对话。 例如：% talk username 允许或拒绝接受信息 命令：mesg (message) 格式：mesg [n/y] 功能：允许或拒绝其它用户向自己所用的终端发送信息。 选项：n 拒绝其它用户向自己所用的终端写信息 y 允许其它用户向自己所用的终端写信息（缺省值） 注释： 例如：% mesg n 给其他用户写信息 命令：write 格式：write username [ttyname] 功能：给其他用户的终端写信息。 选项： 注释：若对方没有拒绝，两用户可进行交谈，键入EOF或Ctrl+C则结束对话。 例如：write username 创建、修改、删除用户和群组 a. 创建群组： 例如： groupadd oinstall 创建群组名为oinstall的组 groupadd -g 344 dba创建组号是344的组，此时在/etc/passwd文件中产生一个组ID（GID）是344的项目。 b. 修改群组： groupmod:该命令用于改变用户组帐号的属性 groupmod –g 新的GID 用户组帐号名 groupmod –n 新组名 原组名：此命令由于改变用户组的名称 c. 删除群组： groupdel 组名：该命令用于删除指定的组帐号 d. 新建用户： 命令： useradd [－d home] [－s shell] [－c comment] [－m [－k template]] [－f inactive] [－e expire ] [－p passwd] [－r] name 主要参数 -c：加上备注文字，备注文字保存在passwd的备注栏中。　 -d：指定用户登入时的启始目录。 -D：变更预设值。 -e：指定账号的有效期限，缺省表示永久有效。 -f：指定在密码过期后多少天即关闭该账号。 -g：指定用户所属的群组。 -G：指定用户所属的附加群组。 -m：自动建立用户的登入目录。 -M：不要自动建立用户的登入目录。 -n：取消建立以用户名称为名的群组。 -r：建立系统账号。 -s：指定用户登入后所使用的shell。 -u：指定用户ID号。 举例： # useradd -g oinstall -G dba oracle 创建Oracle用户 e. 删除用户 命令： userdel 用户名 删除指定的用户帐号 userdel –r 用户名(userdel 用户名;rm 用户名)：删除指定的用户帐号及宿主目录 例：#useradd -g root kkk //把kkk用户加入root组里 f. 修改用户 命令： usermod 修改已有用户的信息 usermod –l 旧用户名 新用户名： 修改用户名 usermod –L 用户名： 用于锁定指定用户账号，使其不能登陆系统 usermod –U 用户名： 对锁定的用户帐号进行解锁 passwd –d 用户名： 使帐号无口令，即用户不需要口令就能登录系统 例：#usermod -l user2 user1 //把用户user2改名为user1 启动、关闭防火墙 永久打开或则关闭 chkconfig iptables on chkconfig iptables off 即时生效：重启后还原 service iptables start service iptables stop 或者： /etc/init.d/iptables start /etc/init.d/iptables stop 启动VSFTP服务 即时启动： /etc/init.d/vsftpd start 即时停止： /etc/init.d/vsftpd stop 开机默认VSFTP服务自动启动: 方法一:(常用\\方便) [root@localhost etc]# chkconfig --list|grep vsftpd ( 查看情况) vsftpd 0:off 1:off 2:off 3:off 4:off 5:off 6:off [root@localhost etc]# chkconfig vsftpd on (执行ON设置) 或者:方法二: 修改文件 /etc/rc.local , 把行/usr/local/sbin/vsftpd & 插入文件中，以实现开机自动启动。 vi技巧 a. 进入输入模式 新增 (append) a ：从光标所在位置後面开始新增资料，光标後的资料随新增资料向後移动。 A：从光标所在列最後面的地方开始新增资料。 插入 (insert) i：从光标所在位置前面开始插入资料，光标後的资料随新增资料向後移动。 I ：从光标所在列的第一个非空白字元前面开始插入资料。 开始 (open) o ：在光标所在列下新增一列并进入输入模式。 O: 在光标所在列上方新增一列并进入输入模式。 b. 退出vi 在指令模式下键入:q,:q!,:wq或:x(注意:号），就会退出vi。其中:wq和:x是存盘退出，而:q是直接退出，如果文件已有新的变化，vi会提示你保存文件而:q命令也会失效，这时你可以用:w命令保存文件后再用:q 退出，或用:wq或:x命令退出，如果你不想保存改变后的文件，你就需要用:q!命令，这个命令将不保存文件而直接退出vi。 c. 删除与修改文件的命令： x：删除光标所在字符。 dd ：删除光标所在的列。 r ：修改光标所在字元，r 後接著要修正的字符。 R：进入取替换状态，新增文字会覆盖原先文字，直到按 [ESC] 回到指令模式下为止。 s：删除光标所在字元，并进入输入模式。 S：删除光标所在的列，并进入输入模式。 d. 屏幕翻滚类命令 Ctrl+u: 向文件首翻半屏 Ctrl+d: 向文件尾翻半屏 Ctrl+f: 向文件尾翻一屏 Ctrl＋b: 向文件首翻一屏 nz: 将第n行滚至屏幕顶部，不指定n时将当前行滚至屏幕顶部。 e. 删除命令 ndw或ndW: 删除光标处开始及其后的n-1个字 do: 删至行首 d$: 删至行尾 ndd: 删除当前行及其后n-1行 x或X: 删除一个字符，x删除光标后的，而X删除光标前的 Ctrl+u: 删除输入方式下所输入的文本 f. 搜索及替换命令 /pattern: 从光标开始处向文件尾搜索pattern ?pattern: 从光标开始处向文件首搜索pattern n: 在同一方向重复上一次搜索命令 N: 在反方向上重复上一次搜索命令 :s/p1/p2/g: 将当前行中所有p1均用p2替代 :n1,n2s/p1/p2/g: 将第n1至n2行中所有p1均用p2替代 :g/p1/s//p2/g: 将文件中所有p1均用p2替换 g. 复制，黏贴 (1) 选定文本块，使用v进入可视模式；移动光标键选定内容 (2) 复制选定块到缓冲区，用y；复制整行，用yy (3) 剪切选定块到缓冲区，用d；剪切整行用dd (4) 粘贴缓冲区中的内容，用p h. 其他 在同一编辑窗打开第二个文件，用:sp [filename] 在多个编辑文件之间切换，用Ctrl+w Copyright © igavin.cc 2019 all right reserved该条目修订时间： 2019-05-22 12:49:52 "},"git/":{"url":"git/","title":"第三章 Git","keywords":"","body":"第三章 Git Git是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。 Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。目前已经成为主流的版本控制软件之一。 Copyright © igavin.cc 2019 all right reserved该条目修订时间： 2019-05-23 20:14:25 "},"git/multiUser.html":{"url":"git/multiUser.html","title":"第1节：Mac 上配置多个git账号","keywords":"","body":"第1节：Mac 上配置多个git账号 第一步先进入ssh配置目录 ​ cd ~/.ssh 1、清空默认全局的username和email（如果没有的话可忽略） 1.1、查看已配置的git列表 ​ git conifg --list 1.2、清空默认的用户名和邮箱 ​ git config --global --unset user.name ​ git config --global --unset user.email 2、给不同的git账户生成ssh-key：比方说一个公司账号，一个个人账号 2.1、公司git生成ssh-key ​ ssh-keygen -t rsa -f id_rsa -C “公司邮箱\" ​ //如果已存在会提示是否覆盖，输入y ​ ​ Enter passphrase (empty for no passphrase): ​ //上面提示你输密码，你可以直接enter，然后再输入一遍 ​ ​ Enter same passphrase again: ​ //返回提示身份认证保存 ​ Your identification has been saved in /User/用户名/.ssh/id_rsa. ​ Your public key has been saved in /User/用户名//ssh/id_rsa.pub. ​ The key fingerprint is: ​ SHA256:巴拉巴拉一大堆… email@igavin.cc ​ The key's randomart image is: ​ 巴拉巴拉一个图 2.2、自己的git生成ssh-key ​ ​ ssh-keygen -t rsa -f id_rsa_personal -C “email@igavin.cc\" ​ //后面的一样的... 3、给他们分别添加到ssh-agent信任列表 3.1、添加公司的到信任列表 ​ ssh-add id_rsa 3.2、这里可能会遇到Error比如 ​ Could not open a connection to your authentication agent. 3.3、那么请先输入 ​ ssh-agent bash 3.4、重复 3.1操作，返回Identity added就是成功了 ​ ssh-add id_rsa ​ //返回这个就表示添加成功了 ​ Identitiy added: ~/.ssh/id_ras 3.5、再次添加个人的到信任列表 ​ ssh-add id_rsa_personal ​ //返回这个就表示添加成功了 ​ Identitiy added: ~/.ssh/id_ras_personal 4、添加他们的公钥到你的git账户中 4.1、复制公司和自己的公钥，然后分别粘贴到git网站的公钥中去 ​ pbcopy ​ pbcopy 5、测试连接 6.1、测试公司git账户连接 ​ ssh -T git@igavin.cc 6.2、连接成功 ​ Hi 公司某某！ You've successfully authenticated…… 6.3、测试自己的 ​ ssh -T git@github.com ​ Hi 想要减肥的你！ You've successfully authenticated…… 到这一步为止，就可以正常的用git了。 [注意]在用ide同步代码的时候可能会提示是否设置全局用户，记得取消掉该选项。 如果一个平台上有多个账号则往下看 6、在config文件配置多个ssh-key 5.1、打开目录，看看有没有config文件，没有的话新建一个 ​ open ~/.ssh/ 5.2、分别配置公司和自己的ssh-key 键 值 规则 Host 主机 随意写，有点关联就行了 Hostname 主机名 必须写正确，是你的git公有地址，比方说：github.com IdentityFile 身份文件 你的rsa具体路径地址 User 用户 可随意写，建议使用Host的前面部分，后面具体clone操作都会用到这个user #公司 Host company.igavin.cc Hostname igavin.cc IdentityFile ~/.ssh/id_rsa User company #个人 Host me.github.com Hostname github.com IdentityFile ~/.ssh/id_rsa_personal User me //更多用户则按上面的顺序继续添加即可 上面的测试连接也换成，同步代码也需要带上配置的user ssh -T git@{config里面的user}.xxx主机名 7、clone push , 这里和以前操作一样，略微带过 //到自己工作的目录，准备下载个工程下来 cd ~/DevEnv/MyGitee/ //原本单个账户的情况 //git clone git@github.com:用户名/Test.git //设置多个账户和config后 git clone git@me.github.com:用户名/Test.git //.....done //.....修改了某些东西 //前往具体的工程目录 cd Test //添加、提交，push等，一步带过啦~~ git add . git pull git commit -m \"test commit\" git push //OVER Copyright © igavin.cc 2019 all right reserved该条目修订时间： 2019-05-23 20:17:31 "},"other/":{"url":"other/","title":"附录 疑难问题","keywords":"","body":"附录 疑难问题 这个章节会记录开发过程中遇到的一些冷门问题。 Copyright © igavin.cc 2019 all right reserved该条目修订时间： 2019-05-13 19:21:53 "},"other/gradleYesAppNo.html":{"url":"other/gradleYesAppNo.html","title":"第1节：gradle项目bootrun正常运行，但springboot主类不可以","keywords":"","body":"第1节：gradle项目bootrun正常运行，但springboot主类不可以 这是一个很诡异的问题，经过多次尝试发现这是gradle构造工具的一个bug，依赖jar下载下来了，gradle依赖列表没显示异常，但是没在自动配置上Dependencies，可以打开project structure(Comman+;)，找到模块依赖中对应的项目看是否报错，八成可能这里会报错，如果有则验证确实是这个原因，可以多尝试几次刷新gradle（推荐），或者把对应的依赖删除重新构建再添加上重新构建（不推荐，猜测的没测试）。 Copyright © igavin.cc 2019 all right reserved该条目修订时间： 2019-05-13 19:21:46 "}}